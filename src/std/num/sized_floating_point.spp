use std::boolean::Bool
use std::cast::From
use std::number::U32
use std::number::S32
use std::limits::Limits
use std::void::Void

use std::num::sized_integer_signed::SizedIntegerSigned
use std::num::sized_integer_unsigned::SizedIntegerUnsigned
use std::num::bases::FloatingPoint

use std::ops::eq::Eq
use std::ops::ord::Ord
use std::ops::add::Add
use std::ops::add::AddAssign
use std::ops::sub::Sub
use std::ops::sub::SubAssign
use std::ops::mul::Mul
use std::ops::mul::MulAssign
use std::ops::div::Div
use std::ops::div::DivAssign
use std::ops::rem::Rem
use std::ops::rem::RemAssign
use std::ops::pow::Pow


# A sized floating point is a floating point type with a provided bit width.
!public
cls SizedFloatingPoint[cmp w: U32] { }


# The sized floating point type extends the base floating point type.
sup [cmp w: U32] SizedFloatingPoint[w] ext FloatingPoint { }


sup [cmp this_w: U32, cmp that_w: U32] SizedFloatingPoint[this_w] ext From[Self, SizedFloatingPoint[that_w]] {
    fun from(that: SizedFloatingPoint[that_w]) -> Self {
        # Destination (this) bits are less than the source (that) bits => truncate.
        case this_w < that_w { ret intrinsics::fptrunc[this_w](that) }

        # Source (that) is unsigned, so zero-extend.
        ret intrinsics::fpext[this_w](that)
    }
}

sup [cmp w: U32] SizedFloatingPoint[w] ext Eq[Rhs=Self] {
    cmp fun eq(&self, that: &Self) -> Bool {
        ret intrinsics::oeq(self, that)
    }

    cmp fun ne(&self, that: &Self) -> Bool {
        ret intrinsics::one(self, that)
    }
}

sup [cmp w: U32] SizedFloatingPoint[w] ext Ord[Rhs=Self] {
    fun ord(&self, that: &Self) -> S32 {
        ret intrinsics::fcmp(self, that)
    }

    cmp fun lt(&self, that: &Self) -> Bool {
        ret intrinsics::olt(self, that)
    }

    cmp fun le(&self, that: &Self) -> Bool {
        ret intrinsics::ole(self, that)
    }

    cmp fun gt(&self, that: &Self) -> Bool {
        ret intrinsics::ogt(self, that)
    }

    cmp fun ge(&self, that: &Self) -> Bool {
        ret intrinsics::oge(self, that)
    }

    cmp fun min(self, that: Self) -> Self {
        ret intrinsics::float_min(self, that)
    }

    cmp fun max(self, that: Self) -> Self {
        ret intrinsics::float_max(self, that)
    }
}

sup [cmp w: U32] SizedFloatingPoint[w] ext Add[Rhs=Self, Ret=Self] {
    cmp fun add(self, that: Self) -> Self {
        ret intrinsics::float_add(self, that)
    }
}

sup [cmp w: U32] SizedFloatingPoint[w] ext AddAssign[Rhs=Self] {
    cmp fun add_assign(&mut self, that: Self) -> Void {
        intrinsics::float_add_assign(self, that)
    }
}

sup [cmp w: U32] SizedFloatingPoint[w] ext Sub[Rhs=Self, Ret=Self] {
    cmp fun sub(self, that: Self) -> Self {
        ret intrinsics::float_sub(self, that)
    }
}

sup [cmp w: U32] SizedFloatingPoint[w] ext SubAssign[Rhs=Self] {
    cmp fun sub_assign(&mut self, that: Self) -> Void {
        intrinsics::float_sub_assign(self, that)
    }
}

sup [cmp w: U32] SizedFloatingPoint[w] ext Mul[Rhs=Self, Ret=Self] {
    cmp fun mul(self, that: Self) -> Self {
        ret intrinsics::float_mul(self, that)
    }
}

sup [cmp w: U32] SizedFloatingPoint[w] ext MulAssign[Rhs=Self] {
    cmp fun mul_assign(&mut self, that: Self) -> Void {
        intrinsics::float_mul_assign(self, that)
    }
}

sup [cmp w: U32] SizedFloatingPoint[w] ext Div[Rhs=Self, Ret=Self] {
    cmp fun div(self, that: Self) -> Self {
        ret intrinsics::float_div(self, that)
    }
}

sup [cmp w: U32] SizedFloatingPoint[w] ext DivAssign[Rhs=Self] {
    cmp fun div_assign(&mut self, that: Self) -> Void {
        intrinsics::float_div_assign(self, that)
    }
}

sup [cmp w: U32] SizedFloatingPoint[w] ext Rem[Rhs=Self, Ret=Self] {
    cmp fun rem(self, that: Self) -> Self {
        ret intrinsics::float_rem(self, that)
    }
}

sup [cmp w: U32] SizedFloatingPoint[w] ext RemAssign[Rhs=Self] {
    cmp fun rem_assign(&mut self, that: Self) -> Void {
        intrinsics::float_rem_assign(self, that)
    }
}

sup [cmp w: U32] SizedFloatingPoint[w] ext Pow[Rhs=Self, Ret=Self] {
    fun pow(self, that: Self) -> Self {
        ret intrinsics::float_powf(self, that)
    }
}

sup [cmp w: U32] SizedFloatingPoint[w] ext Pow[Rhs=S32, Ret=Self] {
    fun pow(self, that: S32) -> Self {
        ret intrinsics::float_powi(self, that)
    }
}

sup [cmp w: U32] SizedFloatingPoint[w] {
    !public
    cmp fun neg(self) -> Self {
        ret intrinsics::float_neg(self)
    }

    !public
    !inline
    fun log2(self) -> Self {
        ret intrinsics::float_log2(self)
    }

    !public
    !inline
    fun log10(self) -> Self {
        ret intrinsics::float_log10(self)
    }

    !public
    !inline
    fun log(self, base: Self) -> Self {
        ret intrinsics::float_log2(self) / intrinsics::float_log2(base)
    }

    !public
    !inline
    fun exp(self) -> Self {
        ret intrinsics::float_exp(self)
    }

    !public
    !inline
    fun exp2(self) -> Self {
        ret intrinsics::float_exp2(self)
    }

    !public
    !inline
    fun exp10(self) -> Self {
        ret intrinsics::float_exp10(self)
    }

    !public
    !inline
    fun sqrt(self) -> Self {
        ret intrinsics::float_sqrt(self)
    }
}

sup [cmp w: U32] SizedFloatingPoint[w] {
    !public
    !inline
    cmp fun abs(self) -> Self {
        ret intrinsics::float_abs(self)
    }

    !public
    !inline
    cmp fun ceil(self) -> Self {
        ret intrinsics::float_ceil(self)
    }

    !public
    !inline
    cmp fun floor(self) -> Self {
        ret intrinsics::float_floor(self)
    }

    !public
    !inline
    cmp fun round(self) -> Self {
        ret intrinsics::float_round(self)
    }

    !public
    !inline
    cmp fun trunc(self) -> Self {
        ret intrinsics::float_trunc(self)
    }
}

sup [cmp w: U32] SizedFloatingPoint[w] {
    !public
    !inline
    fun sin(self) -> Self {
        ret intrinsics::float_sin(self)
    }

    !public
    !inline
    fun cos(self) -> Self {
        ret intrinsics::float_cos(self)
    }

    !public
    !inline
    fun tan(self) -> Self {
        ret intrinsics::float_tan(self)
    }

    !public
    !inline
    fun asin(self) -> Self {
        ret intrinsics::float_asin(self)
    }

    !public
    !inline
    fun acos(self) -> Self {
        ret intrinsics::float_acos(self)
    }

    !public
    !inline
    fun atan(self) -> Self {
        ret intrinsics::float_atan(self)
    }

    !public
    !inline
    fun atan2(self, other: Self) -> Self {
        ret intrinsics::float_atan2(self, other)
    }

    !public
    !inline
    fun sinh(self) -> Self {
        ret intrinsics::float_sinh(self)
    }

    !public
    !inline
    fun cosh(self) -> Self {
        ret intrinsics::float_cosh(self)
    }

    !public
    !inline
    fun tanh(self) -> Self {
        ret intrinsics::float_tanh(self)
    }

    !public
    !inline
    fun asinh(self) -> Self {
        ret self  # todo
    }

    !public
    !inline
    fun acosh(self) -> Self {
        ret self  # todo
    }

    !public
    !inline
    fun atanh(self) -> Self {
        ret self  # todo
    }
}

sup [cmp w: U32] SizedFloatingPoint[w] {
    !public
    !inline
    fun is_signaling_nan(self) -> Bool {
        ret intrinsics::fpclass(self, 0_s32)
    }

    !public
    !inline
    fun is_quiet_nan(self) -> Bool {
        ret intrinsics::fpclass(self, 1_s32)
    }

    !public
    !inline
    fun is_negative_infinity(self) -> Bool {
        ret intrinsics::fpclass(self, 2_s32)
    }

    !public
    !inline
    fun is_negative_normal(self) -> Bool {
        ret intrinsics::fpclass(self, 3_s32)
    }

    !public
    !inline
    fun is_negative_subnormal(self) -> Bool {
        ret intrinsics::fpclass(self, 4_s32)
    }

    !public
    !inline
    fun is_negative_zero(self) -> Bool {
        ret intrinsics::fpclass(self, 5_s32)
    }

    !public
    !inline
    fun is_positive_zero(self) -> Bool {
        ret intrinsics::fpclass(self, 6_s32)
    }

    !public
    !inline
    fun is_positive_subnormal(self) -> Bool {
        ret intrinsics::fpclass(self, 7_s32)
    }

    !public
    !inline
    fun is_positive_normal(self) -> Bool {
        ret intrinsics::fpclass(self, 8_s32)
    }

    !public
    !inline
    fun is_positive_infinity(self) -> Bool {
        ret intrinsics::fpclass(self, 9_s32)
    }

    !public
    !inline
    fun is_positive(self) -> Bool {
        ret self.is_negative().not
    }

    !public
    !inline
    fun is_negative(self) -> Bool {
        # Bit level checking for negative numbers.
        # ret self.to_bits() >> (w - 1_u32) != Self::zero()
        ret false  # todo
    }
}

sup [cmp w: U32] SizedFloatingPoint[w] {
    !public
    !inline
    !compiler_builtin
    fun zero() -> Self { }

    !public
    !inline
    !compiler_builtin
    fun one() -> Self { }

    # !public
    # !inline
    # fun to_bits(self) -> SizedIntegerUnsigned[w] {
    #     ret SizedIntegerUnsigned[w]::from(self)
    # }
}
