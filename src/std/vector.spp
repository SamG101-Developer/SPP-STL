use std::algorithms::Sortable
use std::allocator::Alloc
use std::allocator::GlobalAlloc
use std::array::Arr
use std::boolean::Bool
use std::cast::From
use std::clone::Clone
use std::function::FunRef
use std::generator::GenOnce
use std::generator::GenOpt
use std::iterator::Iterator
use std::iterator::SizedIterator
use std::mem::memory::Memory
use std::number::USize
use std::slice::Slice
use std::void::Void


@public
cls Vec[T, A: Alloc[T] = GlobalAlloc[T]] {
    @public buf: Slice[T, A]
}


sup [T, A] Vec[T, A] {
    type Element = T
    type Allocator = A

    @public
    fun new() -> Vec[T, A] {
        ret Vec[T, A]::new_with_capacity(1_uz)
    }

    @public
    fun new_with_capacity(capacity: USize) -> Vec[T, A] {
        # ret Vec[T, A](buf=A::alloc(capacity))
        ret Vec[T, A]()
    }
}


sup [T] Vec[T] {
    @public
    fun push(&mut self, element: T) -> Void {
        case self.buf.len == self.buf.mem.cap { self.grow_double() }
        self.buf.mem.place(self.buf.len, element)
        self.buf.len += 1_uz
    }

    @public
    fun insert(&mut self, index: USize, element: T) -> Void {
        case self.buf.len == self.buf.mem.cap { self.grow_double() }
        # self.buf.shift(index, 1_uz)
        self.buf.mem.place(index, element)
        self.buf.len += 1_uz
    }

    @public
    fun push_vec(&mut self, that: Vec[T]) -> Void {
        # One time growth check
        let required_cap = self.buf.len + that.buf.len
        loop self.capacity() < required_cap { self.grow_double() }
        self.buf.mem.place_mem(self.buf.len, that.buf.mem)
        self.buf.len += that.buf.len
    }

    @public
    fun insert_vec(&mut self, index: USize, that: Vec[T]) -> Void {
        # One time growth check
        let required_cap = self.buf.len + that.buf.len
        loop self.capacity() < required_cap { self.grow_double() }
        # self.buf.shift(index, that.buf.len)
        self.buf.mem.place_mem(index, that.buf.mem)
        self.buf.len += that.buf.len
    }

    @private
    fun grow_double(&mut self) -> Void {
        let new_cap = self.buf.mem.cap * 2_uz
        # A::realloc(&mut self.buf, new_cap) TODO
    }
}


sup [T] Vec[T] {
    @public
    cor get_head_ref(&self) -> GenOpt[&T] {
        gen with self.get_ref(0_uz)
    }

    @public
    cor get_tail_ref(&self) -> GenOpt[&T] {
        gen with self.get_ref(self.buf.len - 1_uz)
    }

    @public
    cor get_ref(&self, index: USize) -> GenOpt[&T] {
        case index >= self.buf.len { gen }
        gen self.index_ref(index)
    }
}


sup [T] Vec[T] {
    @public
    cor get_head_mut(&mut self) -> GenOpt[&mut T] {
        gen with self.get_mut(0_uz)
    }

    @public
    cor get_tail_mut(&mut self) -> GenOpt[&mut T] {
        gen with self.get_mut(self.buf.len - 1_uz)
    }

    @public
    cor get_mut(&mut self, index: USize) -> GenOpt[&mut T] {
        case index >= self.buf.len { gen }
        gen self.index_mut(index)
    }
}


sup [T] Vec[T] {
    @public
    fun clear(&mut self) -> Void {
        self.buf.mem.clear()
    }

    @public
    fun length(&self) -> USize {
        ret self.buf.len
    }

    @public
    fun capacity(&self) -> USize {
        ret self.buf.mem.cap
    }

    @public
    fun is_empty(&self) -> Bool {
        ret self.buf.len == 0_uz
    }
}


sup [T] Vec[T] {
    @public
    fun resize(&mut self, new_length: USize) -> Void {
        self.buf.resize(new_length)
        self.buf.len = new_length
    }

    @public
    fun shrink_to_fit(&mut self) -> Void {
        self.buf.resize(self.buf.len)
    }
}


sup [T] Vec[T] {
    @public
    cor iter_mov(self) -> Iterator[T] {
        gen with self.buf.iter_mov()
    }

    @public
    cor iter_mut(&mut self) -> Iterator[&mut T] {
        gen with self.buf.iter_mut()
    }

    @public
    cor iter_ref(&self) -> Iterator[&T] {
        gen with self.buf.iter_ref()
    }

    @public
    cor reverse_iter_mov(self) -> Iterator[T] {
        gen with self.buf.reverse_iter_mov()
    }

    @public
    cor reverse_iter_mut(&mut self) -> Iterator[&mut T] {
        gen with self.buf.reverse_iter_mut()
    }

    @public
    cor reverse_iter_ref(&self) -> Iterator[&T] {
        gen with self.buf.reverse_iter_ref()
    }
}


sup [T] Vec[T] ext SizedIterator[T] {
    fun size_hint(&self) -> USize {
        ret self.buf.len
    }
}


sup [T, A] Vec[T, A] ext From[Self, Slice[T, A]] {
    fun from(that: Slice[T, A]) -> Self {
        ret Vec[T, A](buf=that)
    }
}


sup [T, A, cmp n: USize] Vec[T, A] ext From[Self, Arr[T, n, A]] {
    fun from(that: Arr[T, n, A]) -> Self {
        ret Vec[T, A]::from(Slice[T, A]::from(that))
    }
}


# TODO: Constrain T to be Clone
sup [T] Vec[T] ext Clone[Out=Self] {
    fun clone(&self) -> Self {
        # ret Vec[T, A](buf=self.buf.clone())
        ret Vec[T]()
    }
}


# TODO: Constrain T to be Ord
##
sup [T] Vec[T] ext Sortable[T] {
    fun sort(&mut self) -> Void { }

    fun sort_by(&mut self, compare: FunRef[(T, T), Bool]) -> Void { }
}
##


sup [T] Vec[T] ext std::ops::idx::IndexMut[T, USize] {
    cor index_mut(&mut self, index: USize) -> GenOnce[&mut T] {
        gen with self.buf.index_mut(index)
    }
}


sup [T] Vec[T] ext std::ops::idx::IndexRef[T, USize] {
    cor index_ref(&self, index: USize) -> GenOnce[&T] {
        gen with self.buf.index_ref(index)
    }
}


sup [T] Vec[T] ext std::ops::add::Add[Self, Ret=Self] {
    fun add(self, that: Self) -> Self {
        let mut result = self
        result.push_vec(that)
        ret result
    }
}


sup [T] Vec[T] ext std::ops::add::AddAssign[Self] {
    fun add_assign(&mut self, that: Self) -> Void {
        self.push_vec(that)
    }
}
