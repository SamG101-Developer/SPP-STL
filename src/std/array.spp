use std::allocator::Alloc
use std::allocator::GlobalAlloc
use std::memory::Memory
use std::number::bigint::BigInt
use std::number::usize::USize
use std::option::Opt
use std::result::Fail
use std::result::Exception
use std::void::Void


cls BoundsException { }


sup BoundsException ext Exception { }


@public
cls Arr[T, cmp n: BigInt, A = GlobalAlloc[T]] { }


sup [T, A, cmp n: BigInt] Arr[T, n] ext Memory[T, A] {
    @public
    fun len(&self) -> USize {
        ret n
    }
}


@public
cls ArrDynamic[T] { }


sup [T, A] ArrDynamic[T] ext Memory[T, A] { }


sup [T, A] ArrDynamic[T] {
    @no_impl
    @public
    fun new_with_cap(capacity: USize) -> ArrDynamic[T] { }

    @protected
    fun grow_by_one(&mut self) -> Void {
        self.capacity += 1
        case Self::Allocator::reallocate(&mut self, self.capacity) of
            is Fail(err) { }
    }

    @protected
    fun grow_double(&mut self) -> Opt[Void] {
        self.capacity *= 2
        case Self::Allocator::reallocate(&mut self, self.capacity) of
            is Fail(err) { }
    }
}
