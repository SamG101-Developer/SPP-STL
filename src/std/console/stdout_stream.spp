use std::number::U8
use std::number::USize
use std::number::S32
use std::result::Fail
use std::result::Pass
use std::result::Res
use std::slice::Slice
use std::streams::WritableStream
use std::streams::StreamErr
use std::string_view::StrView
use std::void::Void


@public
cmp stdout: StdoutStream = StdoutStream()


@private
cmp stdout_fd: S32 = 1


@private
cls StdoutStream { }


sup StdoutStream ext WritableStream {
    fun write(&mut self, data: &Slice[U8]) -> Res[USize, StreamErr] {
        # Get the data length, form the stream, and write to stdout.
        let len = data.length()
        let stream = StrView::from_utf8(data)
        let val = sppc::fd_write(&stream, 1_uz, len, stdout_fd)

        # Report a failed write (negative value) or return the number of bytes written.
        ret case val of {
            < 0_uz { Fail(err=StreamErr(msg="Failed to write to stdout")) }
            < len { Fail(err=StreamErr(msg="Failed to write all data to stdout")) }
            else { Pass(val=val) }
        }
    }

    fun flush(&mut self) -> Res[Void, StreamErr] {
        let val = sppc::fd_flush(stdout_fd)
        ret case val of {
            != 0 { Fail(err=StreamErr(msg="Failed to flush stdout")) }
            else { Pass[Void]() }
        }
    }
}
