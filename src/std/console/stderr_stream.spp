use std::cffi::CFile
use std::mem::ptr::Ptr
use std::number::U8
use std::number::USize
use std::number::S32
use std::result::Fail
use std::result::Pass
use std::result::Res
use std::slice::Slice
use std::streams::WritableStream
use std::streams::StreamWriteException
use std::void::Void


@public
cmp stderr: StderrStream = StderrStream()


@private
cmp stderr_handle: USize = 2_uz


@private
cls StderrStream { }


sup StderrStream ext WritableStream {
    fun write(&mut self, data: &Slice[U8]) -> Res[USize, StreamWriteException] {
            let file_handle = Ptr[CFile]::from_addr(stderr_handle)
            let val = libc::fputs(&data.buf.mem.ptr.raw, 1_uz, data.length(), &file_handle)
            ret case val < 0_s32 { Fail(err=StreamWriteException(msg="Failed to write to stderr")) } else { Pass(val) }
        }
    
        fun flush(&mut self) -> Res[Void, StreamWriteException] {
            let file_handle = &Ptr[CFile]::from_addr(stderr_handle)
            let val = libc::fflush(&handle)
            ret case val < 0_s32 { Fail(err=StreamWriteException(msg="Failed to flush stderr")) } else { Pass[Void]() }
        }
    
        @no_impl
        fun write_all(&mut self, data: &Slice[U8]) -> Res[USize, StreamWriteException] {
            # ret self.write(data, data.len()).and_then(|| self.flush())
        }
    }
