use std::boolean::Bool
use std::clone::Clone
use std::cast::From
use std::iterator::Iterator
use std::number::U8
use std::number::USize
use std::ops::add::Add
use std::ops::add::AddAssign
use std::ops::eq::Eq
use std::ops::ne::Ne
use std::string_view::StrView
use std::vector::Vec
use std::void::Void
use std::fs::path::Path


##
A string type representing a sequence of bytes. This is a "higher level" abstraction over `Vec[U8]`, compared to the
`StrView` type which  is an immutable, static lifetime span over a pointer to bytes.
##
@public
cls Str {
    @public data: Vec[U8]
}


sup Str {
    @public
    fun new() -> Str {
        ret Str(data=Vec[U8]::new())
    }
}


sup Str {
    @public
    fun to_ascii_uppercase(&self) -> Str {
        # ret self.data.iter_ref().map(U8::to_ascii_uppercase).collect[Str]()
        ret Str::from("")
    }

    @public
    fun to_ascii_lowercase(&self) -> Str {
        # ret self.data.iter_ref().map(U8::to_ascii_lowercase).collect[Str]()
        ret Str::from("")
    }

    @public
    fun split(&self, sep: U8) -> Vec[Str] {
        let mut current: Str = Str::from("")
        let mut strings = Vec[Str]::new()
        
        loop char in self.chars() {
            case char == sep {
                strings.push_back(current)
                current = Str::from("")
            }
            else {
                current += char
            }
        }
        ret strings
    }
}


sup Str {
    @public
    @compiler_builtin
    fun starts_with(&self, needle: StrView) -> Bool { }

    @public
    @compiler_builtin
    fun ends_with(&self, needle: StrView) -> Bool { }
}


sup Str {
    @public
    cor chars(&self) -> Iterator[U8] {
        gen with self.data.clone().iter_mov()
    }

    @public
    fun length(&self) -> USize {
        ret self.data.length()
    }

    @public
    fun is_empty(&self) -> Bool {
        ret self.data.is_empty()
    }
}


sup Str ext From[Self, StrView] {
    @compiler_builtin
    fun from(that: StrView) -> Self { }
}


sup Str ext From[Self, Path] {
    fun from(that: Path) -> Self {
        ret that.path.clone()
    }
}


sup Str ext From[Self, U8] {
    fun from(that: U8) -> Self {
        # Create a Str from a single Char (U8)
        let mut str = Str::new()
        str += that
        ret str
    }
}


sup Str ext Eq[Rhs=Str] {
    fun eq(&self, that: &Str) -> Bool {
        # ret self.data.iter_ref().zip(that.data.iter_ref()).map(U8::eq).all()
        ret false
    }
}


sup Str ext Ne[Rhs=Str] {
    fun ne(&self, that: &Str) -> Bool {
        # ret self.data.iter_ref().zip(that.data.iter_ref()).map(U8::ne).any()
        ret false
    }
}


sup Str ext Clone[Out=Str] {
    fun clone(&self) -> Str {
        ret Str(data=self.data.clone())
    }
}


sup Str ext Add[Rhs=Str, Ret=Str] {
    fun add(self, that: Str) -> Str {
        ret Str(data=self.data + that.data)
    }
}


sup Str ext Add[Rhs=U8, Ret=Str] {
    fun add(self, that: U8) -> Str {
        self.data.push_back(that)
        ret Str(data=self.data)
    }
}


sup Str ext AddAssign[Rhs=Str] {
    fun add_assign(&mut self, that: Str) -> Void {
        self.data += that.data
    }
}


sup Str ext AddAssign[Rhs=U8] {
    fun add_assign(&mut self, that: U8) -> Void {
        self.data.push_back(that)
    }
}
