use std::boolean::Bool
use std::clone::Clone
use std::cast::From
use std::iterator::Iterator
use std::number::U8
use std::ops::add::Add
use std::ops::add::AddAssign
use std::ops::eq::Eq
use std::ops::ne::Ne
use std::string_view::StrView
use std::vector::Vec
use std::void::Void


##
A string type representing a sequence of bytes. This is a "higher level" abstraction over `Vec[U8]`, compared to the
`StrView` type which  is an immutable, static lifetime span over a pointer to bytes.
##
@public
cls Str {
    data: Vec[U8]
}


sup Str {
    @public
    fun to_ascii_uppercase(&self) -> Str {
        # ret self.data.iter_ref().map(U8::to_ascii_uppercase).collect(Str)
        ret Str::from("")
    }

    @public
    fun to_ascii_lowercase(&self) -> Str {
        # ret self.data.iter_ref().map(U8::to_ascii_lowercase).collect(Str)
        ret Str::from("")
    }

    @no_impl
    fun split(&self, sep: U8) -> Vec[Str] {
        let mut current: Str = Str::from("")
        let mut strings = Vec[Str]::new()
        
        loop char in self.chars() {
            case char == sep {
                strings.push(current)
                current = Str::from("")
            }
            else {
                current += char
            }
        }
    }
}


sup Str {
    @public
    cor chars(&self) -> Iterator[U8] {
        gen with self.data.clone().iter_mov()
    }
}


sup Str ext From[Self, StrView] {
    @compiler_builtin
    fun from(that: StrView) -> Self { }
}


sup Str ext Eq[Rhs=Str] {
    fun eq(&self, that: &Str) -> Bool {
        # ret self.data.iter_ref().zip(that.data.iter_ref()).map(U8::eq).all()
        ret false
    }
}


sup Str ext Ne[Rhs=Str] {
    fun ne(&self, that: &Str) -> Bool {
        # ret self.data.iter_ref().zip(that.data.iter_ref()).map(U8::ne).any()
        ret false
    }
}


sup Str ext Clone[Out=Str] {
    @no_impl
    fun clone(&self) -> Str { }
}


sup Str ext Add[Rhs=Str, Ret=Str] {
    @no_impl
    fun add(self, that: Str) -> Str { }
}


sup Str ext Add[Rhs=U8, Ret=Str] {
    @no_impl
    fun add(self, that: U8) -> Str { }
}


sup Str ext AddAssign[Rhs=Str] {
    @no_impl
    fun add_assign(&mut self, that: Str) -> Void { }
}


sup Str ext AddAssign[Rhs=U8] {
    @no_impl
    fun add_assign(&mut self, that: U8) -> Void { }
}
