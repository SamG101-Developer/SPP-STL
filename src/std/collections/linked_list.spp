use std::boolean::Bool
use std::iterator::Iterator
use std::number::USize
use std::option::None
use std::option::Opt
use std::option::Some
use std::shared::Shared
use std::vector::Vec
use std::void::Void


cls LinkedListNode[T] {
    val: T
    prev: Opt[USize]  # Index of the previous node in the list.
    next: Opt[USize]  # Index of the next node in the list.
}


cls LinkedList[T] {
    head: Opt[USize]
    tail: Opt[USize]
    nodes: Vec[LinkedListNode[T]]
}


sup [T] LinkedList[T] {
    @public
    fun push_back(&mut self, value: T) -> USize {
        # Create a new node and add it to the end of the node vector.
        let idx = self.nodes.length()
        let new_node = LinkedListNode(val=value, prev=self.tail, next=None())
        self.nodes.push(new_node)

        # Update the previous tail node to point to the new node.
        case self.tail is Some[USize](val as tail_node) { self.nodes[mut tail_node].next = Some(val=idx) }
        self.tail = Some(val=idx)

        # If the list was empty, set the head to the new node.
        case self.head is None() { self.head = Some(val=idx) }
        ret idx
    }

    @public
    fun push_front(&mut self, value: T) -> USize {
        # Create a new node and add it to the front of the node vector.
        let idx = self.nodes.length()
        let new_node = LinkedListNode(val=value, prev=None(), next=self.head)
        self.nodes.push(new_node)

        # Update the previous head node to point back to the new node.
        case self.head is Some[USize](val as head_node) { self.nodes[mut head_node].prev = Some(val=idx) }
        self.head = Some(val=idx)

        # If the list was empty, set the tail to the new node.
        case self.tail is None() { self.tail = Some(val=idx) }
        ret idx
    }

    @public
    fun push(&mut self, index: USize, value: T) -> USize {
        # Create a new node.
        let idx = self.nodes.length()
        let new_node = LinkedListNode(val=value, prev=None(), next=None())
        self.nodes.push(new_node)

        # Insert the new node at the specified index.
        case index == 0_uz {
            # Inserting at the front.
            self.push_front(value)
        }
        else case index >= self.nodes.length() - 1_uz {
            # Inserting at the back.
            self.push_back(value)
        }
        else {
            # Inserting in the middle.
            let next_node = self.nodes[index]
            let prev_node = self.nodes[next_node.prev.unwrap()]

            # Update borrows.
            self.nodes[mut idx].prev = Some(val=next_node.prev.unwrap())
            self.nodes[mut idx].next = Some(val=index)
            self.nodes[mut prev_node.prev.unwrap()].next = Some(val=idx)
            self.nodes[mut index].prev = Some(val=idx)

            ret idx
        }
    }

    @public
    fun push_back_list(&mut self, other: &mut LinkedList[T]) -> Void {
        # Move all the nodes from the other list to the end of this list, in O(1) time.
        case other.head is None() { ret }  # Other list is empty.
        case self.tail is None() {
            # This list is empty, so just take the other list's nodes.
            self.head = other.head
            self.tail = other.tail
            self.nodes = other.nodes
        }
        else {
            # Link the two lists together.
            let self_tail_idx = self.tail.unwrap()
            let other_head_idx = other.head.unwrap()

            self.nodes[mut self_tail_idx].next = Some(val=other_head_idx)
            other.nodes[mut other_head_idx].prev = Some(val=self_tail_idx)

            self.tail = other.tail
            self.nodes.extend(other.nodes)
        }
    }
}


sup [T] LinkedList[T] {
    @public
    fun pop_back(&mut self) -> Opt[T] {
        case self.tail is None() { ret None() }

        # Get the current tail node.
        let tail_idx = self.tail.unwrap()
        let tail_node = self.nodes.pop(tail_idx)?
        let val = tail_node.val

        # Update the tail to the previous node.
        self.tail = tail_node.prev
        case self.tail of {
            is Some[USize](val as new_tail) { self.nodes[mut new_tail].next = None() }
            is None() { self.head = None() }
        }

        ret Some(val)
    }

    @public
    fun pop_front(&mut self) -> Opt[T] {
        case self.head is None() { ret None() }

        # Get the current head node.
        let head_idx = self.head.unwrap()
        let head_node = self.nodes.pop(head_idx)?
        let val = head_node.val

        # Update the head to the next node.
        self.head = head_node.next
        case self.head of {
            is Some[USize](val as new_head) { self.nodes[mut new_head].prev = None() }
            is None() { self.tail = None() }
        }

        ret Some(val)
    }

    @public
    fun pop(&mut self, index: USize) -> Opt[T] {
        case index >= self.nodes.length() { ret None() }
        let node = self.nodes.pop(index)?
        let val = node.val

        # Update the previous node to point to the next node.
        case node.prev is Some[USize](val as prev_node) { self.nodes[mut prev_node].next = node.next }
        case node.next is Some[USize](val as next_node) { self.nodes[mut next_node].prev = node.prev }

        # Update head and tail if necessary.
        case self.head is Some[USize](val as head_idx) {
            case head_idx == index { self.head = node.next }
        }
        case self.tail is Some[USize](val as tail_idx) {
            case tail_idx == index { self.tail = node.prev }
        }

        ret Some(val)
    }

    @public
    fun clear(&mut self) -> Void {
        # Reset head and tail, and clear nodes.
        self.head = None()
        self.tail = None()
        self.nodes.clear()
    }
}


sup [T] LinkedList[T] {
    @public
    fun is_empty(&self) -> Bool {
        # The list is empty if the head is None.
        ret self.head is None()
    }

    @public
    fun length(&self) -> USize {
        # The length is the number of nodes in the list.
        ret self.nodes.length()
    }
}


sup [T] LinkedList[T] {
    @public
    cor iter_mut(&mut self) -> Iterator[&mut T] {
        # Start from the head and traverse the list.
        let mut current = self.head
        loop current is Some[USize](val as idx) {
            let mut node = self.nodes[mut idx]
            gen &mut node.val
            # current = node.next  TODO: Needs anti-flow support
        }
    }

    @public
    cor iter_ref(&self) -> Iterator[&T] {
        # Start from the head and traverse the list.
        let mut current = self.head
        loop current is Some[USize](val as idx) {
            let node = self.nodes[idx]
            gen &node.val
            # current = node.next  TODO: Needs anti-flow support
        }
    }

    @public
    cor reverse_iter_mut(&mut self) -> Iterator[&mut T] {
        # Start from the tail and traverse the list backwards.
        let mut current = self.tail
        loop current is Some[USize](val as idx) {
            let mut node = self.nodes[mut idx]
            gen &mut node.val
            # current = node.prev  TODO: Needs anti-flow support
        }
    }

    @public
    cor reverse_iter_ref(&self) -> Iterator[&T] {
        # Start from the tail and traverse the list backwards.
        let mut current = self.tail
        loop current is Some[USize](val as idx) {
            let node = self.nodes[idx]
            gen &node.val
            # current = node.prev  TODO: Needs anti-flow support
        }
    }
}
