use std::boolean::Bool
use std::iterator::Iterator
use std::number::USize
use std::option::None
use std::option::Opt
use std::option::Some
use std::shared::Shared
use std::vector::Vec
use std::void::Void


cls LinkedListNode[T] {
    val: T
    prev: Opt[USize]  # Index of the previous node in the list.
    next: Opt[USize]  # Index of the next node in the list.
}


cls LinkedList[T] {
    head: Opt[USize]
    tail: Opt[USize]
    nodes: Vec[LinkedListNode[T]]
}


sup [T] LinkedList[T] {
    @public
    fun push_back(&mut self, value: T) -> USize {
        # Create a new node and add it to the end of the node vector.
        let idx = self.nodes.length()
        let new_node = LinkedListNode(val=value, prev=self.tail, next=None())
        self.nodes.push(new_node)

        # Update the previous tail node to point to the new node.
        case self.tail is Some[USize](val as tail_node) { self.nodes[mut tail_node].next = Some(val=idx) }
        self.tail = Some(val=idx)

        # If the list was empty, set the head to the new node.
        case self.head is None() { self.head = Some(val=idx) }
        ret idx
    }

    @public
    fun push_front(&mut self, value: T) -> USize {
        # Create a new node and add it to the front of the node vector.
        let idx = self.nodes.length()
        let new_node = LinkedListNode(val=value, prev=None(), next=self.head)
        self.nodes.push(new_node)

        # Update the previous head node to point back to the new node.
        case self.head is Some[USize](val as head_node) { self.nodes[mut head_node].prev = Some(val=idx) }
        self.head = Some(val=idx)

        # If the list was empty, set the tail to the new node.
        case self.tail is None() { self.tail = Some(val=idx) }
        ret idx
    }
}


sup [T] LinkedList[T] {
    @public
    fun pop_back(&mut self) -> Opt[T] {
        case self.tail is None() { ret None() }

        let tail_idx = self.tail.unwrap()
        let tail_node = self.nodes[tail_idx]
        let val = tail_node.val

        # Update the tail to the previous node.
        self.tail = tail_node.prev
        case self.tail is Some[USize](val as new_tail) { self.nodes[mut new_tail].next = None() }
        case self.tail is None() { self.head = None() }

        ret Some(val)
    }

    @public
    fun pop_front(&mut self) -> Opt[T] {
        case self.head is None() { ret None() }

        let head_idx = self.head.unwrap()
        let head_node = self.nodes[head_idx]
        let val = head_node.val

        # Update the head to the next node.
        self.head = head_node.next
        case self.head is Some[USize](val as new_head) { self.nodes[mut new_head].prev = None() }
        case self.head is None() { self.tail = None() }

        ret Some(val)
    }

    @public
    fun pop(&mut self, index: USize) -> Opt[T] {
        case index >= self.nodes.length() { ret None() }
        let node = self.nodes[index]
        let val = node.val

        # Update the previous node to point to the next node.
        case node.prev is Some[USize](val as prev_node) { self.nodes[mut prev_node].next = node.next }
        case node.next is Some[USize](val as next_node) { self.nodes[mut next_node].prev = node.prev }

        # Update head and tail if necessary.
        case self.head is Some[USize](val as head_idx) {
            case head_idx == index { self.head = node.next }
        }
        case self.tail is Some[USize](val as tail_idx) {
            case tail_idx == index { self.tail = node.prev }
        }

        ret Some(val)
    }
}


sup [T] LinkedList[T] {
    @public
    fun is_empty(&self) -> Bool {
        # The list is empty if the head is None.
        ret self.head is None()
    }

    @public
    fun length(&self) -> USize {
        # The length is the number of nodes in the list.
        ret self.nodes.length()
    }
}


sup [T] LinkedList[T] {
    @public
    cor iter_mut(&mut self) -> Iterator[&mut T] {
        # Start from the head and traverse the list.
        let mut current = self.head
        loop current is Some[USize](val as idx) {
            let node = self.nodes[idx]
            gen &mut node.val
            current = node.next
        }
    }

    @public
    cor iter_ref(&self) -> Iterator[&T] {
        # Start from the head and traverse the list.
        let mut current = self.head
        loop current is Some[USize](val as idx) {
            let node = self.nodes[idx]
            gen &node.val
            current = node.next
        }
    }

    @public
    cor reverse_iter_mut(&mut self) -> Iterator[&mut T] {
        # Start from the tail and traverse the list backwards.
        let mut current = self.tail
        loop current is Some[USize](val as idx) {
            let node = self.nodes[idx]
            gen &mut node.val
            current = node.prev
        }
    }

    @public
    cor reverse_iter_ref(&self) -> Iterator[&T] {
        # Start from the tail and traverse the list backwards.
        let mut current = self.tail
        loop current is Some[USize](val as idx) {
            let node = self.nodes[idx]
            gen &node.val
            current = node.prev
        }
    }
}
