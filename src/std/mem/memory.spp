use std::allocator::Alloc
use std::allocator::GlobalAlloc
use std::clone::Clone
use std::copy::Copy
use std::number::USize
use std::option::Opt
use std::single::Single
use std::void::Void


@public
cls Memory[T, A: Alloc[T] = GlobalAlloc[T]] {
    ptr: Single[T, A]
    cap: USize
}


sup [T, A] Memory[T, A] {
    @public
    fun new(cap: USize) -> Memory[T, A] {
        ret Memory[T, A](cap)
    }
}


sup [T] Memory[T] {
    @public type Element = T

    @public
    fun capacity(&self) -> USize {
        ret self.cap
    }

    @public
    @compiler_builtin
    fun clear(&mut self) -> Void { }

    @protected
    @compiler_builtin
    fun take(&mut self, index: USize) -> Opt[T] { }

    @protected
    @compiler_builtin
    fun place(&mut self, index: USize, value: T) -> Void { }

    @protected
    @compiler_builtin
    fun place_mem(&mut self, index: USize, value: Memory[T]) -> Void { }
}


sup [T] Memory[T] ext Clone[Out=Memory[T]] {
    @compiler_builtin
    fun clone(&self) -> Memory[T] { }
}


sup [T: Copy] Memory[T] ext Copy { }
