use std::generator::GenOnce
use std::iterator::IndexMut
use std::iterator::IndexRef
use std::iterator::Iterator
use std::iterator::IterMov
use std::iterator::IterMut
use std::iterator::IterRef
use std::number::usize::USize
use std::void::Void


cls Memory[T] {
    @private
    ptr: Single[T]

    @private
    capacity: USize
}


sup [T] Memory[T] {
    type Element = T

    @public
    fun cap(&self) -> USize {
        ret self.capacity
    }

    @public
    @abstract_method
    fun len(&self) -> USize { }

    @public
    @compiler_builtin
    fun clear(&mut self) -> Void { }

    @protected
    @compiler_builtin
    fun take(&mut self, index: USize) -> Opt[T] { }

    @protected
    @compiler_builtin
    fun place(&mut self, index: USize, value: T) -> Void { }
}


sup [T: Clone] Memory[T] ext Clone[Rhs=Self] {
    @public
    fun clone(&self) -> Memory[T] { }
}


sup [T: Copy] Memory[T] ext Copy { }


sup [T] Memory[T] ext IterMov[T] {
    @compiler_builtin
    cor iter_mov(self) -> Iterator[T] { }
}


sup [T] Memory[T] ext IterMut[T] {
    @compiler_builtin
    cor iter_mut(&mut self) -> Iterator[&mut T] { }
}


sup [T] Memory[T] ext IterRef[T] {
    @compiler_builtin
    cor iter_ref(&self) -> Iterator[&T] { }
}


sup [T] Memory[T] ext IndexMut[T, USize] {
    @compiler_builtin
    cor index_mut(&mut self, index: USize) -> GenOnce[&mut T] { }
}


sup [T] Memory[T] ext IndexRef[T, USize] {
    @compiler_builtin
    cor index_ref(&self, index: USize) -> GenOnce[&T] { }
}
