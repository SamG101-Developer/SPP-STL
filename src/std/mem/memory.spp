use std::allocator::Alloc
use std::allocator::GlobalAlloc
use std::boolean::Bool
use std::clone::Clone
use std::copy::Copy
use std::number::USize
use std::option::Opt
use std::single::Single
use std::void::Void
use std::ops::del::Del


# The Memory type is the lowest-level contiguous storage abstraction, representing a block of memory allocated on the
# heap. It is capacity aware, but not length aware, and cannot be resized. It provides methods for taking an element
# from the storage, or putting placing an element into the storage.
#
# The Memory type is allocator aware, allowing for customizable allocation strategies. In order to fit with the
# ownership model, it maintains a uniquely owned Single pointer (the location of the memory on the heap) and a capacity
# field (the number of elements that can be stored in the memory). The allocator falls through to the Single pointer.
!public
cls Memory[T, A: Alloc[T] = GlobalAlloc[T]] {
    ptr: Single[T, A]
    cap: USize
    alloc: A
}

sup [T, A: Alloc[T]] Memory[T, A] {
    !public type Element = T

    !public
    fun new(cap: USize, alloc: A = A()) -> Memory[T, A] {
        ret Memory(cap, alloc)
    }

    !public
    fun capacity(&self) -> USize {
        ret self.cap
    }

    !public
    fun clear(&mut self) -> Void {
        self.alloc.deallocate(&mut self)
        self.cap = 0_uz
    }

    !public
    fun is_empty(&self) -> Bool {
        ret self.cap == 0_uz
    }

    !protected
    !compiler_builtin
    fun take(&mut self, index: USize) -> Opt[T] { }

    !protected
    !compiler_builtin
    fun place(&mut self, index: USize, value: T) -> Void { }

    !protected
    !compiler_builtin
    fun place_mem(&mut self, index: USize, value: Memory[T]) -> Void { }
}

sup [T: Clone[T], A: Alloc[T]] Memory[T, A] ext Clone[Out=Memory[T, A]] {
    !compiler_builtin
    fun clone(&self) -> Self { }
}

sup [T: Copy, A: Alloc[T]] Memory[T, A] ext Copy { }

sup [T, A: Alloc[T]] Memory[T, A] ext Del {
    !compiler_builtin
    fun del(&mut self) -> Void {
        self.clear()
    }
}
