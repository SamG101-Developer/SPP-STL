use std::copy::Copy
use std::mem::memory::Memory
use std::mem::ptr::Ptr
use std::number::USize
use std::number::S32
use std::option::Opt
use std::option::None
use std::option::Some
use std::result::Exception
use std::single::Single
use std::void::Void


cls MemoryIncompatibleSize {}
sup MemoryIncompatibleSize ext Exception { }


@compiler_builtin
fun size_of[T]() -> USize {
    # Returns the size of a type at compile time.
}


@compiler_builtin
fun size_of_value[T](value: T) -> USize {
    # Handles heap size checking for types that are not known at compile time.
}


@compiler_builtin
fun mem_cmp[T](a: &T, b: &T, n: USize) -> S32 {
    # Compares two memory regions byte by byte.
}


fun malloc[T](n: USize) -> Opt[Memory[T]] {
    # Determine the size and get an allocated pointer.
    let size = n * size_of[T]()
    let raw = libc::malloc[T](size)
    ret case raw.to_addr() == 0_uz { None() } else { Some(val=Memory(ptr=Single(raw), cap)) }
}


fun calloc[T](n: USize) -> Opt[Memory[T]] {
    # Determine the size and get an allocated pointer.
    let cap = n * size_of[T]()
    let raw_ptr = libc::calloc[T](n, size_of[T]())
    ret case raw_ptr.addr == 0_uz { None() } else { Some(val=Memory(ptr=Single(raw), cap)) }
}


fun realloc[T](mut mem: &mut Memory[T], n: USize) -> Opt[Void] {
    # Determine the size and get a reallocated pointer.
    let cap = n * size_of[T]()
    libc::realloc(&mut mem.ptr.raw, cap)

    # If the new pointer is null, return None (failed reallocation).
    case mem.ptr.raw.to_addr() == 0_uz { ret None() }

    # Otherwise, update the length.
    mem.cap = cap
    ret Some[Void]()
}


fun free[T](mem: Memory[T]) -> Void {
    # Free the memory pointed to by the pointer.
    libc::free(mem.ptr.raw)
}
