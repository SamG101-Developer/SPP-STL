use std::copy::Copy
use std::mem::memory::Memory
use std::number::USize
use std::number::S32
use std::option::Opt
use std::option::None
use std::option::Some
use std::single::Single
use std::void::Void


# Returns the size of a type at compile time.
!public
!inline
!compiler_builtin
fun size_of[T]() -> USize { }

# Handles heap size checking for types that are not known at compile time.
!public
!inline
!compiler_builtin
fun size_of_value[T](value: T) -> USize { }

# Compares two memory regions byte by byte.
!public
!inline
!compiler_builtin
fun mem_cmp[T](a: &T, b: &T, n: USize) -> S32 { }

# Set the byte value of a memory region to a specified value.
!public
!inline
!compiler_builtin
fun mem_set[T](dest: &mut T, value: U8, n: USize) -> Void { }

# Allocates a block of memory on the heap for "n" elements of type "T". The memory will return None for each access
# immediately after malloc is used, ebcause there are no values inside the memory. But the memory object itself is
# initialized, fllowing standard ownership rules.
!public
fun malloc[T](n: USize) -> Opt[Memory[T]] {
    let cap = n * size_of[T]()
    let raw = sppc::mem_alloc[T](cap)
    ret Some(val=raw)
}


!public
fun calloc[T](n: USize) -> Opt[Memory[T]] {
    # Determine the size and get an allocated pointer.
    let cap = n * size_of[T]()
    let raw = sppc::mem_calloc[T](n, size_of[T]())
    ret Some(val=raw)
}


!public
fun realloc[T](mem: Memory[T], n: USize) -> Opt[Memory[T]] {
    # Determine the size and get a reallocated pointer.
    let cap = n * size_of[T]()
    let mut new_mem = sppc::mem_realloc(mem, cap)

    # Update the capacity attribute of the memory (S++ side).
    new_mem.cap = cap
    ret Some(val=new_mem)
}


!public
fun free[T](mem: Memory[T]) -> Void {
    # Free the memory pointed to by the pointer.
    sppc::mem_dealloc(mem)
}


!public
fun swap[T](a: &mut T, b: &mut T) -> Void {
    let temp = take(a)
    a@ = take(b)
    b@ = temp
}


!public
fun replace[T](dest: &mut T, src: T) -> T {
    let old = take(dest)
    dest@ = src
    ret old
}


!public
!compiler_builtin
fun take[T](src: &mut T) -> T {
    # This is safe because of uniform default initialization, where the "src" will be replaced with a default value for
    # T, based on the standard object initialization: T(). Effectively the same as "mem::replace(src, T())".
}


!public
!compiler_builtin
fun drop[T](val: T) -> Void {
    # Safely disposes of a value, calling its destructor if necessary. This is safe as it takes ownership, so an
    # uninitialized value cannot be left behind in the caller's context (at runtime).
}