use std::copy::Copy
use std::mem::memory::Memory
use std::number::USize
use std::number::S32
use std::option::Opt
use std::option::None
use std::option::Some
use std::single::Single
use std::void::Void


@public
@inline
@compiler_builtin
fun size_of[T]() -> USize {
    # Returns the size of a type at compile time.
}


@public
@inline
@compiler_builtin
fun size_of_value[T](value: T) -> USize {
    # Handles heap size checking for types that are not known at compile time.
}


@public
@inline
@compiler_builtin
fun mem_cmp[T](a: &T, b: &T, n: USize) -> S32 {
    # Compares two memory regions byte by byte.
}


@public
fun malloc[T](n: USize) -> Opt[Memory[T]] {
    # Determine the size and get an allocated pointer.
    let cap = n * size_of[T]()
    let raw = sppc::mem_alloc[T](cap)
    ret Some(val=raw)  # TODO: Handle allocation failure.
}


@public
fun calloc[T](n: USize) -> Opt[Memory[T]] {
    # Determine the size and get an allocated pointer.
    let cap = n * size_of[T]()
    let raw = sppc::mem_calloc[T](n, size_of[T]())
    ret Some(val=raw)  # TODO: Handle allocation failure.
}


@public
fun realloc[T](mem: Memory[T], n: USize) -> Opt[Memory[T]] {
    # Determine the size and get a reallocated pointer.
    let cap = n * size_of[T]()
    let mut new_mem = sppc::mem_realloc(mem, cap)

    # Update the capacity attribute of the memory (S++ side).
    new_mem.cap = cap
    ret Some(val=new_mem)
}


@public
fun free[T](mem: Memory[T]) -> Void {
    # Free the memory pointed to by the pointer.
    sppc::mem_dealloc(mem)
}
