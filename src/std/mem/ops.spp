use std::copy::Copy
use std::mem::memory::Memory
use std::number::USize
use std::number::S32
use std::option::Opt
use std::option::None
use std::option::Some
use std::single::Single
use std::void::Void


@public
@inline
@compiler_builtin
fun size_of[T]() -> USize {
    # Returns the size of a type at compile time.
}


@public
@inline
@compiler_builtin
fun size_of_value[T](value: T) -> USize {
    # Handles heap size checking for types that are not known at compile time.
}


@public
@inline
@compiler_builtin
fun mem_cmp[T](a: &T, b: &T, n: USize) -> S32 {
    # Compares two memory regions byte by byte.
}


@public
fun malloc[T](n: USize) -> Opt[Memory[T]] {
    # Determine the size and get an allocated pointer.
    let cap = n * size_of[T]()
    let raw = sppc::mem_alloc[T](cap)
    ret Some(val=raw)  # TODO: Handle allocation failure.
}


@public
fun calloc[T](n: USize) -> Opt[Memory[T]] {
    # Determine the size and get an allocated pointer.
    let cap = n * size_of[T]()
    let raw = sppc::mem_calloc[T](n, size_of[T]())
    ret Some(val=raw)  # TODO: Handle allocation failure.
}


@public
fun realloc[T](mem: Memory[T], n: USize) -> Opt[Memory[T]] {
    # Determine the size and get a reallocated pointer.
    let cap = n * size_of[T]()
    let mut new_mem = sppc::mem_realloc(mem, cap)

    # Update the capacity attribute of the memory (S++ side).
    new_mem.cap = cap
    ret Some(val=new_mem)
}


@public
fun free[T](mem: Memory[T]) -> Void {
    # Free the memory pointed to by the pointer.
    sppc::mem_dealloc(mem)
}


@public
fun swap[T](a: &mut T, b: &mut T) -> Void {
    let temp = take(a)
    a@ = take(b)
    b@ = temp
}


@public
fun replace[T](dest: &mut T, src: T) -> T {
    let old = take(dest)
    dest@ = src
    ret old
}


@public
@compiler_builtin
fun take[T](src: &mut T) -> T {
    # This is safe because of uniform default initialization, where the "src" will be replaced with a default value for
    # T, based on the standard object initialization: T().
}


@public
@compiler_builtin
fun drop[T](val: T) -> Void {
    # Safely disposes of a value, calling its destructor if necessary. This is safe as it takes ownership, so an
    # uninitialized value cannot be left behind in the caller's context (at runtime).
}