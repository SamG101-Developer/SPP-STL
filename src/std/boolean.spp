use std::copy::Copy
use std::cast::From
use std::clone::Clone
use std::number::U32


@public
cls Bool { }

sup Bool ext Copy { }


sup Bool ext Clone[Out=Bool] {
    @compiler_builtin
    fun clone(&self) -> Bool { }
}


sup Bool ext std::ops::and_::And[Rhs=Bool] {
    @compiler_builtin
    fun and_(self, that: Bool) -> Bool { }
}


sup Bool ext std::ops::ior_::Ior[Rhs=Bool] {
    @compiler_builtin
    fun ior_(self, that: Bool) -> Bool { }
}


sup Bool ext std::ops::bit_and::BitAnd[Rhs=Bool, Ret=Bool] {
    @compiler_builtin
    fun bit_and(self, that: Bool) -> Bool { }
}


sup Bool ext std::ops::bit_ior::BitIor[Rhs=Bool, Ret=Bool] {
    @compiler_builtin
    fun bit_ior(self, that: Bool) -> Bool { }
}


sup Bool ext std::ops::bit_xor::BitXor[Rhs=Bool, Ret=Bool] {
    @compiler_builtin
    fun bit_xor(self, that: Bool) -> Bool { }
}


sup Bool ext std::ops::bit_not::BitNot[Ret=Bool] {
    @compiler_builtin
    fun bit_not(&self) -> Bool { }
}


sup Bool ext std::ops::eq::Eq[Rhs=Bool] {
    @compiler_builtin
    fun eq(&self, that: &Bool) -> Bool { }
}


sup Bool ext std::ops::ne::Ne[Rhs=Bool] {
    @compiler_builtin
    fun ne(&self, that: &Bool) -> Bool { }
}


sup [cmp n: U32] Bool ext From[std::num::sized_integer_signed::SizedIntegerSigned[n]] {
    fun from(value: SizedIntegerSigned[n]) -> Bool {
        ret value > SizedIntegerSigned[n]::zero()
    }
}


sup [cmp n: U32] Bool ext From[std::num::sized_integer_unsigned::SizedIntegerUnsigned[n]] {
    fun from(value: SizedIntegerUnsigned[n]) -> Bool {
        ret value > SizedIntegerUnsigned[n]::zero()
    }
}


sup [cmp n: U32] Bool ext From[std::num::sized_floating_point::SizedFloatingPoint[n]] {
    fun from(value: SizedFloatingPoint[n]) -> Bool {
        ret value > SizedFloatingPoint[n]::zero()
    }
}
