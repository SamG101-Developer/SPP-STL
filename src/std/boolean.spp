use std::copy::Copy
use std::cast::From
use std::clone::Clone
use std::number::U32

use std::num::sized_integer_signed::SizedIntegerSigned
use std::num::sized_integer_unsigned::SizedIntegerUnsigned
use std::num::sized_floating_point::SizedFloatingPoint

use std::ops::and_::And
use std::ops::ior_::Ior
use std::ops::bit_and::BitAnd
use std::ops::bit_ior::BitIor
use std::ops::bit_xor::BitXor
use std::ops::bit_not::BitNot
use std::ops::eq::Eq

!public
cls Integral { }

!public
cls Bool { }
sup Bool ext Copy { }
sup Bool ext Integral { }


sup Bool ext And[Rhs=Bool] {
    !inline
    !compiler_builtin
    cmp fun and_(self, that: Bool) -> Bool { }
}


sup Bool ext Ior[Rhs=Bool] {
    !inline
    !compiler_builtin
    cmp fun ior_(self, that: Bool) -> Bool { }
}


sup Bool ext BitAnd[Rhs=Bool, Ret=Bool] {
    !inline
    !compiler_builtin
    cmp fun bit_and(self, that: Bool) -> Bool { }
}


sup Bool ext BitIor[Rhs=Bool, Ret=Bool] {
    !inline
    !compiler_builtin
    cmp fun bit_ior(self, that: Bool) -> Bool { }
}


sup Bool ext BitXor[Rhs=Bool, Ret=Bool] {
    !inline
    !compiler_builtin
    cmp fun bit_xor(self, that: Bool) -> Bool { }
}


sup Bool ext BitNot[Ret=Bool] {
    !inline
    !compiler_builtin
    cmp fun bit_not(self) -> Bool { }
}


sup Bool ext Eq[Rhs=Bool] {
    !inline
    !compiler_builtin
    fun eq(&self, that: &Bool) -> Bool { }

    !inline
    !compiler_builtin
    fun ne(&self, that: &Bool) -> Bool { }
}


sup [cmp n: U32] Bool ext From[Self, SizedIntegerSigned[n]] {
    fun from(that: SizedIntegerSigned[n]) -> Bool {
        ret that > SizedIntegerSigned[n]::zero()
    }
}


sup [cmp n: U32] Bool ext From[Self, SizedIntegerUnsigned[n]] {
    fun from(that: SizedIntegerUnsigned[n]) -> Bool {
        ret that > SizedIntegerUnsigned[n]::zero()
    }
}


sup [cmp n: U32] Bool ext From[Self, SizedFloatingPoint[n]] {
    fun from(that: SizedFloatingPoint[n]) -> Bool {
        ret that > SizedFloatingPoint[n]::zero()
    }
}
