use std::boolean::Bool
use std::function::FunRef
use std::generator::Gen
use std::generator::GenOnce
use std::number::USize
use std::option::None
use std::option::Opt
use std::option::Some
use std::void::Void


@public
cls Iterator[T] { }
sup [T] Iterator[T] ext Gen[T] { }


@public
cls SizedIterator[T] { }
sup [T] SizedIterator[T] {
    @public
    @abstract_method
    fun size_hint(&self) -> USize { }
}


sup [T] Iterator[T] {
    # Concatenate this iterator with another iterator of the same element type. Iterate out of all elements from this
    # iterator, then all elements from the other iterator.
    @public
    cor concat(self, other: Iterator[T]) -> Iterator[T] {
        gen with self
        gen with other
    }

    @public
    cor cycle(self) -> Iterator[T] {
        loop true {
            gen with self
        }
    }

    @public
    cor drop(self, count: USize) -> Iterator[T] {
        let mut index = 0_uz
        loop item in self {
            case index >= count {
                gen item
            }
            index += 1_uz
        }
    }

    @public
    cor filter(self, predicate: FunRef[(&T,), Bool]) -> Iterator[T] {
        loop item in self {
            case predicate(&item) {
                gen item
            }
        }
    }

    @public
    cor take(self, count: USize) -> Iterator[T] {
        let mut index = 0_uz
        loop item in self {
            case index < count {
                gen item
                index += 1_uz
                skip
            }
            exit
        }
    }

    @public
    cor map[U](self, mapper: FunRef[(T,), U]) -> Iterator[U] {
        loop item in self {
            gen mapper(item)
        }
    }

    @public
    cor slice(self, start: USize, end: USize) -> Iterator[T] {
        let mut index = 0_uz
        loop item in self {
            case index >= start and index < end {
                gen item
            }
            index += 1_uz
        }
    }

    @public
    cor step_by(self, step: USize) -> Iterator[T] {
        let mut index = 0_uz
        loop item in self {
            case index % step == 0_uz {
                gen item
            }
            index += step
        }
    }

    @public
    fun count(self) -> USize {
        let mut count = 0_uz
        loop item in self {
            count += 1_uz
        }
        ret count
    }

    @public
    fun fold[U](self, initial: U, reducer: FunRef[(U, T), U]) -> U {
        let mut acc = initial
        loop item in self {
            acc = reducer(acc, item)
        }
        ret acc
    }

    @public
    fun all(self, predicate: FunRef[(T,), Bool]) -> Bool {
        loop item in self {
            case predicate(item).not {
                ret false
            }
        }
        ret true
    }

    @public
    fun any(self, predicate: FunRef[(T,), Bool]) -> Bool {
        loop item in self {
            case predicate(item) {
                ret true
            }
        }
        ret false
    }

    @public
    fun find(self, predicate: FunRef[(&T,), Bool]) -> Opt[T] {  # todo: this should fail (could be Opt[&T] i think)
        loop item in self {
            case predicate(&item) {
                ret Some(val=item)
            }
        }
        ret None()
    }

    @public
    fun for_each(self, action: FunRef[(T,), Void]) -> Void {
        loop item in self {
            action(item)
        }
    }
}
