use std::boolean::Bool
use std::clone::Clone
use std::copy::Copy
use std::function::FunRef
use std::ops::try::Try

# todo: superimpose Copy on None
# todo: change None to NoneT
# todo: declare a cmp constant None for NoneT (prevents having to use None() everywhere)


@public
cls Some[T] { val: T }


@public
cls None { }


@public
type Opt[T] = Some[T] or None


sup [T: Copy] Opt[T] ext Copy { }


sup [T: Clone[Out=T]] Opt[T] ext Clone[Out=Opt[T]] {
    fun clone(&self) -> Opt[T] {
        ret case self of
            is Some[T](val) { Some[T](val.clone()) }
            is None() { None() }
    }
}


sup [T] Opt[T] {
    @public
    @inline
    fun is_some(&self) -> Bool {
        ret self is Some[T](..)
    }

    @public
    @inline
    fun is_some_and(self, pred: FunMov[(T,), Bool]) -> Bool {
        ret case self of
            is Some[T](val) { pred(val) }
            is None() { false }
    }

    @public
    @inline
    fun is_none(&self) -> Bool {
        ret self is None()
    }

    @public
    @inline
    fun is_none_or(self, pred: FunMov[(T,), Bool]) -> Bool {
        ret case self of
            is Some[T](val) { pred(val) }
            is None() { true }
    }
}


sup [T] Opt[T] {
    @public
    @inline
    fun and_[U](self, that: Opt[U]) -> Opt[U] {
        ret case self of
            is Some[T](..) { that }
            is None() { None() }
    }

    @public
    @inline
    fun and_then[U](self, that: FunMov[(T,), Opt[U]]) -> Opt[U] {
        ret case self of
            is Some[T](val) { that(val) }
            is None() { None() }
    }
}


sup [T] Opt[T] {
    @public
    @inline
    fun ior_[U](self, that: Opt[U]) -> Opt[T] {
        ret case self of
            is Some[T](..) { self }
            is None() { that }
    }

    @public
    @inline
    fun ior_else[U](self, that: FunMov[(), Opt[U]]) -> Opt[T] {
        ret case self of
            is Some[T](..) { self }
            is None() { that() }
    }
}


sup [T] Opt[T] {
    @public
    @inline
    fun xor(self, that: Opt[T]) -> Opt[T] {
        ret case (self, that) of
            is (Some[T](val), None()) { Some(val) }
            is (None(), Some[T](val)) { Some(val) }
            else { None() }
    }
}


sup [T] Opt[T] {
    @public
    @inline
    fun map[U](self, f: FunMov[(T,), U]) -> Opt[U] {
        ret case self of
            is Some[T](val) { Some(val=f(val)) }
            is None() { None() }
    }

    @public
    @inline
    fun map_or[U](self, default: U, f: FunMov[(T,), U]) -> U {
        ret case self of
            is Some[T](val) { f(val) }
            is None() { default }
    }

    @public
    @inline
    fun map_or_else[U](self, default: FunMov[(), U], f: FunMov[(T,), U]) -> U {
        ret case self of
            is Some[T](val) { f(val) }
            is None() { default() }
    }
}


sup [T] Opt[T] {
    @public
    @inline
    fun ok_or[U](self, err: U) -> Res[T, U] {
        ret case self of
            is Some[T](val) { Pass(val) }
            is None() { Fail(err) }
    }

    @public
    @inline
    fun ok_or_else[U](self, err: FunMov[(), U]) -> Res[T, U] {
        ret case self of
            is Some[T](val) { Pass(val) }
            is None() { Fail(err()) }
    }
}


sup[T] Opt[T] {
    @public
    @inline
    fun unwrap(self) -> T {
        ret case self of
            is Some[T](val) { val }
            is None() { std::abort::abort("called `unwrap` on a `None` value") }
    }

    @public
    @inline
    fun unwrap_or(self, default: T) -> T {
        ret case self of
            is Some[T](val) { val }
            is None() { default }
    }

    @public
    @inline
    fun unwrap_or_else(self, default: FunMov[(), T]) -> T {
        ret case self of
            is Some[T](val) { val }
            is None() { default() }
    }
}


sup [T] Opt[T] ext Try[T, None] {
    fun op_is_output(&self) -> Bool {
        ret self is Some[T](..)
    }
}
