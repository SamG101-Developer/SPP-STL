use std::boolean::Bool
use std::cast::From
use std::number::U32
use std::number::U64
use std::number::USize
use std::range::Range
use std::vector::Vec
use std::void::Void
use std::num::sized_integer_unsigned::SizedIntegerUnsigned


@public
cls BigUInt {
    data: Vec[U32]
}


sup [cmp bit_width: U32] BigUInt ext From[Self, SizedIntegerUnsigned[bit_width]] {
    fun from(that: SizedIntegerUnsigned[bit_width]) -> Self {
        let val = BigUInt()
        let mut temp = that
        loop temp != 0_u32 {
            val.data.push(U32::from(temp & 0xFFFFFFFF_u32))
            temp >>= 32_u32
        }
        case val.data.length() == 0_uz { val.data.push(0_u32) }
        ret val
    }
}


sup BigUInt {
    @public
    fun is_even(&self) -> Bool {
        ret self.data[0].is_even()
    }

    @public
    fun is_odd(&self) -> Bool {
        ret self.data[0].is_odd()
    }

    @public
    fun zero() -> Self {
        let val = BigUInt()
        val.data.push(0_u32)
        ret val
    }

    @public
    fun one() -> Self {
        let val = BigUInt()
        val.data.push(1_u32)
        ret val
    }

    @public
    fun is_zero(&self) -> Bool {
        ret self.data.length() == 1_uz and self.data[0] == 0_u32
    }

    @public
    fun is_one(&self) -> Bool {
        ret self.data.length() == 1_uz and self.data[0] == 1_u32
    }

    @private
    fun trim(&mut self) -> Void {
        loop self.data.length() > 1_uz and self.data.last() == 0_u32 {
            self.data.pop()
        }
    }

    @private
    fun bit_length(&self) -> USize {
        ##
        case self.is_zero() { ret 0_uz }
        let last = self.data.get_tail_ref().clone()
        let bits = 32_u32 * (self.data.length() - 1_uz)
        loop last != 0_u32 {
            last >>= 1_u32
            bits += 1_u32
        }
        ret bits
        ##
        ret 0_uz  # Placeholder
    }
}


sup BigUInt ext std::ops::bit_and::BitAnd[Rhs=Self, Ret=Self] {
    fun bit_and(self, that: Self) -> Self {
        let val = self.clone()
        val &= that
        ret val
    }
}


sup BigUInt ext std::ops::bit_ior::BitIor[Rhs=Self, Ret=Self] {
    fun bit_ior(self, that: Self) -> Self {
        let val = self.clone()
        val |= that
        ret val
    }
}


sup BigUInt ext std::ops::bit_xor::BitXor[Rhs=Self, Ret=Self] {
    fun bit_xor(self, that: Self) -> Self {
        let val = self.clone()
        val ^= that
        ret val
    }
}


sup BigUInt ext std::ops::bit_not::BitNot[Ret=Self] {
    fun bit_not(self) -> Self {
        let val = self.clone()
        loop i in Range::between(0_uz, val.data.length()) {
            val.data[i] = val.data[i].bit_not()
        }
        ret val
    }
}


sup BigUInt ext std::ops::bit_shl::BitShl[Rhs=Self, Ret=Self] {
    fun bit_shl(self, that: Self) -> Self {
        let val = self.clone()
        val <<= that
        ret val
    }
}


sup BigUInt ext std::ops::bit_shr::BitShr[Rhs=Self, Ret=Self] {
    fun bit_shr(self, that: Self) -> Self {
        let val = self.clone()
        val >>= that
        ret val
    }
}


sup BigUInt ext std::ops::add::Add[Rhs=Self, Ret=Self] {
    fun add(self, that: Self) -> Self {
        let val = self.clone()
        val += that
        ret val
    }
}


sup BigUInt ext std::ops::sub::Sub[Rhs=Self, Ret=Self] {
    fun sub(self, that: Self) -> Self {
        let val = self.clone()
        val -= that
        ret val
    }
}


sup BigUInt ext std::ops::mul::Mul[Rhs=Self, Ret=Self] {
    fun mul(self, that: Self) -> Self {
        let val = self.clone()
        val *= that
        ret val
    }
}


sup BigUInt ext std::ops::div::Div[Rhs=Self, Ret=Self] {
    fun div(self, that: Self) -> Self {
        let val = self.clone()
        val /= that
        ret val
    }
}


sup BigUInt ext std::ops::rem::Rem[Rhs=Self, Ret=Self] {
    fun rem(self, that: Self) -> Self {
        let val = self.clone()
        val %= that
        ret val
    }
}


sup BigUInt ext std::ops::pow::Pow[Rhs=Self, Ret=Self] {
    fun pow(self, that: Self) -> Self {
        let val = self.clone()
        val **= that
        ret val
    }
}


sup BigUInt ext std::ops::bit_and::BitAndAssign[Rhs=Self] {
    fun bit_and_assign(&mut self, that: Self) -> Void {
        let len = self.data.length().min(that.data.length())
        self.data.resize(len)
        loop i in Range::between(0_uz, len) {
            self.data[i] = self.data[i] & that.data[i]
        }
        self.trim()
    }
}


sup BigUInt ext std::ops::bit_ior::BitIorAssign[Rhs=Self] {
    fun bit_ior_assign(&mut self, that: Self) -> Void {
        let len = self.data.length().max(that.data.length())
        self.data.resize(len)
        loop i in Range::between(0_uz, len) {
            let a = self.data[i]
            let b = case i < that.data.length() { that.data[i] } else { 0_u32 }
            self.data[i] = a | b
        }
        self.trim()
    }
}


sup BigUInt ext std::ops::bit_xor::BitXorAssign[Rhs=Self] {
    fun bit_xor_assign(&mut self, that: Self) -> Void {
        let len = self.data.length().max(that.data.length())
        self.data.resize(len)
        loop i in Range::between(0_uz, len) {
            let a = self.data[i]
            let b = case i < that.data.length() { that.data[i] } else { 0_u32 }
            self.data[i] = a ^ b
        }
        self.trim()
    }
}


sup BigUInt ext std::ops::bit_shl::BitShlAssign[Rhs=Self] {
    fun bit_shl_assign(&mut self, that: Self) -> Void {
        case that.is_zero() { ret }
        let word_shift = that.bit_length() / 32_u32
        let bit_shift = that.bit_length() % 32_u32

        let val = self.clone()
        val.data.resize(self.data.length() + USize::from(word_shift) + 1_uz)

        loop i in Range::between(0_uz, self.data.length()) {
            let shifted = U64::from(self.data[i]) << U64::from(bit_shift)
            val.data[i + USize::from(word_shift)] |= U32::from(shifted & 0xFFFFFFFF_u64)
            val.data[i + USize::from(word_shift) + 1_uz] |= U32::from(shifted >> 32)
        }

        self.data = val.data
        self.trim()
    }
}


sup BigUInt ext std::ops::bit_shr::BitShrAssign[Rhs=Self] {
    fun bit_shr_assign(&mut self, that: Self) -> Void {
        case that.is_zero() { ret }
        let word_shift = that.bit_length() / 32_u32
        let bit_shift = that.bit_length() % 32_u32
        let val = self.clone()

        case USize::from(word_shift) >= self.data.length() {
            self.data.clear()
            self.data.push(0_u32)
            ret
        }

        loop i in Range::between(word_shift, self.data.length()) {
            let shifted = U64::from(self.data[i])
            case i + 1_uz < self.data.length() { shifted |= U64::from(self.data[i + 1_uz]) << 32 }
            shifted >>= U64::from(bit_shift)
            val.data[i - USize::from(word_shift)] = U32::from(shifted & 0xFFFFFFFF_u64)
        }

        self.data = val.data
        self.trim()
    }
}


sup BigUInt ext std::ops::add::AddAssign[Rhs=Self] {
    fun add_assign(&mut self, that: Self) -> Void {
        let len = self.data.length().max(that.data.length())
        self.data.resize(len)
        let carry = 0_u64

        loop i in Range::between(0_uz, len) {
            let a = self.data[i]
            let b = case i < that.data.length() { that.data[i] } else { 0_u32 }
            let sum = U64::from(a) + U64::from(b) + carry
            self.data[i] = U32::from(sum & 0xFFFFFFFF_u64)
            carry = sum >> 32
        }

        case carry != 0_u64 { self.data.push(U32::from(carry)) }
    }
}


sup BigUInt ext std::ops::sub::SubAssign[Rhs=Self] {
    fun sub_assign(&mut self, that: Self) -> Void {
        case self < that { std::abort::abort("BigUInt::sub: subtraction would result in negative value") }
        let borrow = 0_u64

        loop i in Range::between(0_uz, self.data.length()) {
            let a = U64::from(self.data[i])
            let b = case i < that.data.length() { U64::from(that.data[i]) } else { 0_u64 }
            let sub = a - b - borrow
            self.data.push(U32::from(sub & 0xFFFFFFFF_u64))
            borrow = (sub >> 63) & 0x1_u64
        }

        self.trim()
    }
}


sup BigUInt ext std::ops::mul::MulAssign[Rhs=Self] {
    fun mul_assign(&mut self, that: Self) -> Void {
        # Skip for known answers.
        case self.is_zero() or that.is_zero() { ret BigUInt::zero() }
        case self.is_one() { ret that.clone() }
        case that.is_one() { ret self.clone() }

        let val = BigUInt()
        val.data.resize(self.data.length() + that.data.length())

        loop i in Range::between(0_uz, self.data.length()) {
            let mut carry = 0_u64
            loop j in Range::between(0_uz, that.data.length()) {
                let a = U64::from(self.data[i])
                let b = U64::from(that.data[j])
                let existing = U64::from(val.data[i + j])
                let prod = a * b + existing + carry
                val.data[i + j] = U32::from(prod & 0xFFFFFFFF_u64)
                carry = prod >> 32
            }
            case carry != 0_u64 {
                val.data[i + that.data.length()] += U32::from(carry)
            }
        }

        self.data = val.data
        self.trim()
    }
}


sup BigUInt ext std::ops::div::DivAssign[Rhs=Self] {
    fun div_assign(&mut self, that: Self) -> Void {
        # Skip for known answers.
        case that.is_zero() { std::abort::abort("BigUInt::div: division by zero") }
        case that.is_one() { ret self.clone() }
        case self < that { ret BigUInt::zero() }

        let dividend = self.clone()
        let mut divisor = that.clone()
        let mut quotient = BigUInt::zero()
        let mut current_quotient = BigUInt::one()

        let shift = dividend.bit_length() - divisor.bit_length()
        divisor <<= shift
        quotient <<= shift + 1

        loop shift >= 0_u32 {
            case dividend >= divisor {
                dividend -= divisor
                quotient.data[0] |= 1 << shift
            }
            divisor >>= 1
            shift -= 1_u32
        }

        self.data = quotient.data
        self.trim()
        ret quotient
    }
}


sup BigUInt ext std::ops::rem::RemAssign[Rhs=Self] {
    fun rem_assign(&mut self, that: Self) -> Void {
        self -= (self / that) * that
    }
}


sup BigUInt ext std::ops::pow::PowAssign[Rhs=Self] {
    fun pow_assign(&mut self, that: Self) -> Void {
        let mut val = BigUInt::one()
        let mut base = self.clone()
        let mut exponent = that.clone()

        loop exponent != BigUInt::zero() {
            case (exponent.data[0] & 1_u32) != 0_u32 { val *= base.clone() }
            base *= base.clone()
            exponent >>= BigUInt::one()
        }

        self.data = val.data
    }
}


sup BigUInt ext std::ops::eq::Eq[Rhs=Self] {
    fun eq(&self, that: &BigUInt) -> Bool {
        ret self.data == that.data
    }
}


sup BigUInt ext std::ops::ne::Ne[Rhs=Self] {
    fun ne(&self, that: &BigUInt) -> Bool {
        ret self.data != that.data
    }
}


sup BigUInt ext std::ops::ge::Ge[Rhs=Self] {
    fun ge(&self, that: &BigUInt) -> Bool {
        ret that.le(self)
    }
}


sup BigUInt ext std::ops::gt::Gt[Rhs=Self] {
    fun gt(&self, that: &BigUInt) -> Bool {
        ret that.lt(self)
    }
}


sup BigUInt ext std::ops::le::Le[Rhs=Self] {
    fun le(&self, that: &BigUInt) -> Bool {
        ret that.gt(self).not
    }
}


sup BigUInt ext std::ops::lt::Lt[Rhs=Self] {
    fun lt(&self, that: &BigUInt) -> Bool {
        case self.data.length() of {
            < that.data.length() { ret true }
            > that.data.length() { ret false }
        }

        loop i in Range::between(self.data.length(), -1_uz).step_by(-1_uz) {
            case self.data[i] < that.data[i] { ret true }
            case self.data[i] > that.data[i] { ret false }
        }
        ret false
    }
}
