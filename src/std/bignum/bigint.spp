use std::boolean::Bool
use std::cast::From
use std::limits::Limits
use std::number::U32
use std::void::Void
use std::bignum::biguint::BigUInt
use std::num::sized_integer_unsigned::SizedIntegerUnsigned
use std::num::sized_integer_signed::SizedIntegerSigned


@public
cls BigInt {
    sign: Bool
    data: BigUInt
}


sup [cmp bit_width: U32] BigInt ext From[Self, SizedIntegerUnsigned[bit_width]] {
    fun from(that: SizedIntegerUnsigned[bit_width]) -> Self {
        ret BigInt(sign=false, data=BigUInt::from(that))
    }
}


sup [cmp bit_width: U32] BigInt ext From[Self, SizedIntegerSigned[bit_width]] {
    fun from(that: SizedIntegerSigned[bit_width]) -> Self {
        let unsigned = SizedIntegerUnsigned[bit_width]::from(that)
        ret BigInt(sign=that.is_negative(), data=BigUInt::from(unsigned))
    }
}


sup BigInt ext std::ops::bit_and::BitAnd[Rhs=Self, Ret=Self] {
    fun bit_and(self, that: Self) -> Self {
        # Forward to BigUInt implementation for magnitude operation
        let result_data = self.data.bit_and(that.data)
        let result_sign = self.sign and that.sign
        ret BigInt(sign=result_sign, data=result_data)
    }
}


sup BigInt ext std::ops::bit_ior::BitIor[Rhs=Self, Ret=Self] {
    fun bit_ior(self, that: Self) -> Self {
        # Forward to BigUInt implementation for magnitude operation
        let result_data = self.data.bit_ior(that.data)
        let result_sign = self.sign or that.sign
        ret BigInt(sign=result_sign, data=result_data)
    }
}


sup BigInt ext std::ops::bit_xor::BitXor[Rhs=Self, Ret=Self] {
    fun bit_xor(self, that: Self) -> Self {
        # Forward to BigUInt implementation for magnitude operation
        let result_data = self.data.bit_xor(that.data)
        let result_sign = self.sign != that.sign
        ret BigInt(sign=result_sign, data=result_data)
    }
}


sup BigInt ext std::ops::bit_not::BitNot[Ret=Self] {
    fun bit_not(self) -> Self {
        # Forward to BigUInt implementation for magnitude operation
        let result_data = self.data.bit_not()
        let result_sign = self.sign.not
        ret BigInt(sign=result_sign, data=result_data)
    }
}


sup BigInt ext std::ops::bit_shl::BitShl[Rhs=Self, Ret=Self] {
    fun bit_shl(self, that: Self) -> Self {
        # Forward to BigUInt implementation for magnitude operation
        let result_data = self.data.bit_shl(that.data)
        ret BigInt(sign=self.sign, data=result_data)
    }
}


sup BigInt ext std::ops::bit_shr::BitShr[Rhs=Self, Ret=Self] {
    fun bit_shr(self, that: Self) -> Self {
        # Forward to BigUInt implementation for magnitude operation
        let result_data = self.data.bit_shr(that.data)
        ret BigInt(sign=self.sign, data=result_data)
    }
}


sup BigInt ext std::ops::add::Add[Rhs=Self, Ret=Self] {
    fun add(self, that: Self) -> Self {
        # Handle sign cases
        case self.sign == that.sign {
            let result_data = self.data.add(that.data)
            ret BigInt(sign=self.sign, data=result_data)
        }
        else case self.data >= that.data {
            let result_data = self.data.sub(that.data)
            ret BigInt(sign=self.sign, data=result_data)
        }
        else {
            let result_data = that.data.sub(self.data)
            ret BigInt(sign=that.sign, data=result_data)
        }
    }
}


sup BigInt ext std::ops::sub::Sub[Rhs=Self, Ret=Self] {
    fun sub(self, that: Self) -> Self {
        # Handle sign cases
        case self.sign != that.sign {
            let result_data = self.data.add(that.data)
            ret BigInt(sign=self.sign, data=result_data)
        }
        else case self.data >= that.data {
            let result_data = self.data.sub(that.data)
            ret BigInt(sign=self.sign, data=result_data)
        }
        else {
            let result_data = that.data.sub(self.data)
            ret BigInt(sign=self.sign.not, data=result_data)
        }
    }
}


sup BigInt ext std::ops::mul::Mul[Rhs=Self, Ret=Self] {
    fun mul(self, that: Self) -> Self {
        let result_data = self.data.mul(that.data)
        let result_sign = self.sign != that.sign
        ret BigInt(sign=result_sign, data=result_data)
    }
}


sup BigInt ext std::ops::div::Div[Rhs=Self, Ret=Self] {
    fun div(self, that: Self) -> Self {
        let result_data = self.data.div(that.data)
        let result_sign = self.sign != that.sign
        ret BigInt(sign=result_sign, data=result_data)
    }
}


sup BigInt ext std::ops::rem::Rem[Rhs=Self, Ret=Self] {
    fun rem(self, that: Self) -> Self {
        let result_data = self.data.rem(that.data)
        ret BigInt(sign=self.sign, data=result_data)
    }
}


sup BigInt ext std::ops::pow::Pow[Rhs=Self, Ret=Self] {
    fun pow(self, that: Self) -> Self {
        let result_data = self.data.pow(that.data)
        let result_sign = case that.data.is_even() { true } else { self.sign }
        ret BigInt(sign=result_sign, data=result_data)
    }
}


sup BigInt ext std::ops::bit_and::BitAndAssign[Rhs=Self] {
    fun bit_and_assign(&mut self, that: Self) -> Void {
        let result = self.bit_and(that)
        self.sign = result.sign
        self.data = result.data
    }
}


sup BigInt ext std::ops::bit_ior::BitIorAssign[Rhs=Self] {
    fun bit_ior_assign(&mut self, that: Self) -> Void {
        let result = self.bit_ior(that)
        self.sign = result.sign
        self.data = result.data
    }
}


sup BigInt ext std::ops::bit_xor::BitXorAssign[Rhs=Self] {
    fun bit_xor_assign(&mut self, that: Self) -> Void {
        let result = self.bit_xor(that)
        self.sign = result.sign
        self.data = result.data
    }
}


sup BigInt ext std::ops::bit_shl::BitShlAssign[Rhs=Self] {
    fun bit_shl_assign(&mut self, that: Self) -> Void {
        let result = self.bit_shl(that)
        self.sign = result.sign
        self.data = result.data
    }
}


sup BigInt ext std::ops::bit_shr::BitShrAssign[Rhs=Self] {
    fun bit_shr_assign(&mut self, that: Self) -> Void {
        let result = self.bit_shr(that)
        self.sign = result.sign
        self.data = result.data
    }
}


sup BigInt ext std::ops::add::AddAssign[Rhs=Self] {
    fun add_assign(&mut self, that: Self) -> Void {
        let result = self.add(that)
        self.sign = result.sign
        self.data = result.data
    }
}


sup BigInt ext std::ops::sub::SubAssign[Rhs=Self] {
    fun sub_assign(&mut self, that: Self) -> Void {
        let result = self.sub(that)
        self.sign = result.sign
        self.data = result.data
    }
}


sup BigInt ext std::ops::mul::MulAssign[Rhs=Self] {
    fun mul_assign(&mut self, that: Self) -> Void {
        let result = self.mul(that)
        self.sign = result.sign
        self.data = result.data
    }
}


sup BigInt ext std::ops::div::DivAssign[Rhs=Self] {
    fun div_assign(&mut self, that: Self) -> Void {
        let result = self.div(that)
        self.sign = result.sign
        self.data = result.data
    }
}


sup BigInt ext std::ops::rem::RemAssign[Rhs=Self] {
    fun rem_assign(&mut self, that: Self) -> Void {
        let result = self.rem(that)
        self.sign = result.sign
        self.data = result.data
    }
}


sup BigInt ext std::ops::pow::PowAssign[Rhs=Self] {
    fun pow_assign(&mut self, that: Self) -> Void {
        let result = self.pow(that)
        self.sign = result.sign
        self.data = result.data
    }
}


sup BigInt ext std::ops::eq::Eq[Rhs=Self] {
    fun eq(&self, that: &BigInt) -> Bool {
        ret self.sign == that.sign and self.data.eq(&that.data)
    }
}


sup BigInt ext std::ops::ne::Ne[Rhs=Self] {
    fun ne(&self, that: &BigInt) -> Bool {
        ret self.sign != that.sign or self.data.ne(&that.data)
    }
}


sup BigInt ext std::ops::ge::Ge[Rhs=Self] {
    fun ge(&self, that: &BigInt) -> Bool {
        case self.sign != that.sign {
            ret self.sign.not
        }
        else case self.sign {
            ret self.data.ge(&that.data)
        }
        else {
            ret self.data.le(&that.data)
        }
    }
}


sup BigInt ext std::ops::gt::Gt[Rhs=Self] {
    fun gt(&self, that: &BigInt) -> Bool {
        case self.sign != that.sign {
            ret self.sign.not
        }
        else case self.sign {
            ret self.data.gt(&that.data)
        }
        else {
            ret self.data.lt(&that.data)
        }
    }
}


sup BigInt ext std::ops::le::Le[Rhs=Self] {
    fun le(&self, that: &BigInt) -> Bool {
        case self.sign != that.sign {
            ret self.sign
        }
        else case self.sign {
            ret self.data.le(&that.data)
        }
        else {
            ret self.data.ge(&that.data)
        }
    }
}


sup BigInt ext std::ops::lt::Lt[Rhs=Self] {
    fun lt(&self, that: &BigInt) -> Bool {
        case self.sign != that.sign {
            ret self.sign
        }
        else case self.sign {
            ret self.data.lt(&that.data)
        }
        else {
            ret self.data.gt(&that.data)
        }
    }
}
