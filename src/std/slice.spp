use std::allocator::Alloc
use std::allocator::GlobalAlloc
use std::array::Arr
use std::cast::From
use std::clone::Clone
use std::iterator::Iterator
use std::generator::GenOnce
use std::mem::memory::Memory
use std::number::U8
use std::number::USize
use std::option::None
use std::string::Str
use std::string_view::StrView
use std::vector::Vec
use std::void::Void
use std::ops::idx::IndexRef
use std::ops::idx::IndexMut


# The Slice type in S++ is a dynamic array. It has a fixed size, but given at runtime. The Array type's fixed size is
# given at compiletime. The Slice type provides a length aware view over a block of memory, and provides methods for
# iterating over the elements, as well as indexing into the slice. The Slice type is allocator aware, and can be used
# with any allocator that implements the Alloc trait.
#
# Internally, the Slice composes the Memory type, because the Memory type has impementation details that would not
# benefit from being exposed at the Slice level, such as the take and place methods.
cls Slice[E, A: Alloc[E, A] = GlobalAlloc[E]] {
    mem: Memory[E, A]
    len: USize
}

sup [E, A: Alloc[E, A]] Slice[E, A] {
    type Element = E
    type Allocator = A

    !public
    fun new(len: USize, alloc: A = A()) -> Self {
        ret Slice[E, A](mem=Memory[E, A]::new(len, alloc), len=len)
    }

    !public
    fun new_with_capacity(cap: USize, len: USize, alloc: A = A()) -> Self {
        ret Slice[E, A](mem=Memory[E, A]::new(cap), len=0_uz)
    }

    !public
    fun length(&self) -> USize {
        ret self.len
    }

    !public
    fun split(self, at: USize) -> (Self, Self) {
        # TODO

        let first = Slice[E, A]()
        let second = Slice[E, A]()
        ret (first, second)
    }

    !public
    !compiler_builtin
    cor iter_mov(self) -> Iterator[E] { }

    !public
    !compiler_builtin
    cor iter_mut(&mut self) -> Iterator[&mut E] { }

    !public
    !compiler_builtin
    cor iter_ref(&self) -> Iterator[&E] { }

    !public
    !compiler_builtin
    cor reverse_iter_mov(self) -> Iterator[E] { }

    !public
    !compiler_builtin
    cor reverse_iter_mut(&mut self) -> Iterator[&mut E] { }

    !public
    !compiler_builtin
    cor reverse_iter_ref(&self) -> Iterator[&E] { }

    !public
    !compiler_builtin
    cor get_ref(&self) -> GenOnce[&E or None] { }

    !public
    !compiler_builtin
    cor get_mut(&mut self) -> GenOnce[&mut E or None] { }
}

sup [E: Clone[E], A: Alloc[E, A]] Slice[E, A] ext Clone[Out=Self] {
    fun clone(&self) -> Self {
        ret Slice[E, A]()
    }
}

sup [E, cmp n: USize, A: Alloc[E, A]] Slice[E, A] ext From[Self, Arr[E, n, A]] {
    fun from(that: Arr[E, n, A]) -> Self {
        ret Slice[E, A](mem=Memory[A=A](ptr=that.mem.ptr, cap=n), len=n)
    }
}

sup Slice[U8] ext From[Self, Str] {
    fun from(that: Str) -> Self {
        # The issue is that "mem" in Str has an allocator already fixed on U8,
        # not the generic A here, which is a type mismatch. So we remove the A
        # completely, allowing it to inherit off of the Str's allocator.
        ret Slice[U8](mem=that.data.buf.mem, len=that.data.buf.len)
    }
}

sup [A: Alloc[U8, A]] Slice[U8, A] ext From[Self, StrView] {
    !compiler_builtin
    fun from(that: StrView) -> Self { }
}

sup [E, A: Alloc[E, A]] Slice[E, A] ext From[Self, Vec[E, A]] {
    fun from(that: Vec[E, A]) -> Self {
        ret Slice[E, A](mem=Memory[A=A](ptr=that.buf.mem.ptr, cap=that.buf.mem.cap), len=that.buf.len)
    }
}

sup [E, A: Alloc[E, A]] Slice[E, A] ext From[Self, Memory[E, A]] {
    fun from(that: Memory[E, A]) -> Self {
        ret Slice[E, A](mem=that, len=that.capacity())
    }
}

sup [E, A: Alloc[E, A]] Slice[E, A] ext IndexMut[E, USize] {
    !compiler_builtin
    cor index_mut(&mut self, index: USize) -> GenOnce[&mut E] { }
}

sup [E, A: Alloc[E, A]] Slice[E, A] ext IndexRef[E, USize] {
    !compiler_builtin
    cor index_ref(&self, index: USize) -> GenOnce[&E] { }
}
