use std::function::FunRef
use std::number::U64
use std::result::Ret
use std::result::Pass
use std::result::Fail
use std::void::Void
use std::threading::mutex::LockErr
use std::threading::mutex::Mutex


@public
cls CondVar {
    id: U64
}


sup CondVar {
    @public
    fun new() -> Ret[CondVar, LockErr] {
        # Create a new mutex using the sppc threading API.
        let id = sppc::condvar_create()
        case id == 0 { ret Fail(err=LockErr(msg="Failed to create condition variable")) }
        ret CondVar(id)
    }

    @public
    fun wait(self, mutex: &Mutex, pred: FunRef[(), Bool]) -> Ret[Void, LockErr] {
        # Wait on the condition variable, releasing the associated mutex.
        # TODO: Implement predicate handling to avoid spurious wake-ups.
        let val = sppc::condvar_wait(self.id, mutex.id)
        case val != 0 { ret Fail(err=LockErr(msg="Failed to wait on condition variable")) }
        ret Pass[Void]()
    }

    @public
    fun signal_one(self) -> Ret[Void, LockErr] {
        # Signal one thread waiting on the condition variable.
        let val = sppc::condvar_signal(self.id)
        case val != 0 { ret Fail(err=LockErr(msg="Failed to signal condition variable")) }
        ret Pass[Void]()
    }

    @public
    fun signal_all(self) -> Ret[Void, LockErr] {
        # Wake up all threads waiting on the condition variable.
        let val = sppc::condvar_broadcast(self.id)
        case val != 0 { ret Fail(err=LockErr(msg="Failed to broadcast condition variable")) }
        ret Pass[Void]()
    }
}


sup CondVar ext std::ops::del::Del {
    fun del(self) -> Void {
        # Destroy the condition variable using the sppc threading API.
        sppc::condvar_destroy(self.id)
    }
}
