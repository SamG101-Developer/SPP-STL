use std::boolean::Bool
use std::number::S32
use std::result::Fail
use std::result::Pass
use std::result::Res
use std::void::Void
use std::threading::mutex::LockErr


@public
cls SpinLock {
    @public id: S32
}


sup SpinLock {
    @public
    fun new() -> Res[SpinLock, LockErr] {
        # Create a new spin lock using the sppc threading API.
        let id = sppc::spinlock_create()
        ret Pass(val=SpinLock(id))
    }

    @public
    fun lock(&self) -> Res[Void, LockErr] {
        # Acquire the spin lock using the sppc threading API.
        let spin_id = sppc::spinlock_lock(self.id)
        case spin_id == 0 { ret Fail(err=LockErr(msg="Failed to acquire spin lock"))  }
        ret Pass[Void]()
    }

    @public
    fun try_lock(&self) -> Res[Bool, LockErr] {
        # Try to acquire the spin lock using the sppc threading API.
        let spin_id = sppc::spinlock_trylock(self.id)
        case spin_id == 0 { ret Fail(err=LockErr(msg="Failed to try acquire spin lock"))  }
        ret Pass(val=spin_id == 1)
    }

    @public
    fun unlock(&self) -> Res[Void, LockErr] {
        # Release the spin lock using the sppc threading API.
        let spin_id = sppc::spinlock_unlock(self.id)
        case spin_id == 0 { ret Fail(err=LockErr(msg="Failed to release spin lock"))  }
        ret Pass[Void]()
    }
}
