use std::number::S32
use std::result::Fail
use std::result::Pass
use std::result::Res
use std::string_view::StrView
use std::void::Void


@public
cls Mutex {
    @public id: S32
}


@public
cls MutexLockGard {
    @public id: S32
}


@public
cls LockErr {
    @public msg: StrView
}


sup Mutex {
    @public
    fun new() -> Res[Mutex, LockErr] {
        # Create a new mutex using the sppc threading API.
        let id = sppc::mutex_create()
        case id == 0 { ret Fail(err=LockErr(msg="Failed to create mutex")) }
        ret Mutex(id)
    }

    @public
    fun lock(&self) -> Res[MutexLockGard, LockErr] {
        # Lock the mutex using the sppc threading API.
        let guard_id = sppc::mutex_lock(self.id)
        case guard_id == 0 { ret Fail(err=LockErr(msg="Failed to lock mutex")) }
        ret Pass(val=MutexLockGard(id=guard_id))
    }

    @public
    cor try_lock(&self) -> Res[MutexLockGard, LockErr] {
        # Try to lock the mutex using the sppc threading API.
        let guard_id = sppc::mutex_try_lock(self.id)
        case guard_id == 0 { ret Fail(err=LockErr(msg="Failed to try to lock mutex")) }
        ret Pass(val=MutexLockGard(id=guard_id))
    }

    @public
    fun unlock(&self) -> Void {
        # Unlock the mutex using the sppc threading API.
        sppc::mutex_unlock(self.id)
    }
}


sup Mutex ext std::ops::del::Del {
    fun del(self) -> Void {
        # Destroy the mutex using the sppc threading API.
        sppc::mutex_destroy(self.id)
    }
}
