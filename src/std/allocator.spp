use std::mem::memory::Memory
use std::number::USize
use std::result::Pass
use std::result::Res
use std::string_view::StrView
use std::void::Void


!public
cls AllocErr {
    !public msg: StrView
}

sup AllocErr {
    !public
    fun new(msg: StrView) -> Self { ret Self(msg) }
}

!public
cls Layout {
    !public size: USize
    !public align: USize
}


!public
cls Alloc[E] { }


# The Alloc implementation defines the interface for memory allocation, deallocation, and reallocation. It is designed
# to be extended by specific allocator implementations, such as GlobalAlloc. The methods in Alloc are abstract, meaning
# that they must be implemented by any subclass that extends Alloc. This allows for flexibility in how memory is
# managed, while still providing a consistent interface for allocation operations.
#
# The required methods are the allocate and de-allocate methods, which handle the basic memory management tasks. The
# other methods can be implemented but have stable default behaviour by using the required allocation methods, and other
# memory utilities, particularly from sppc.
#
# Todo: Memory[E, A] <- Somehow fill the "A" argument, differing for inheritance.
sup [E] Alloc[E] {

    # Allocates a block of memory for the specified layout. The method returns a Result type, which can either be a
    # successful allocation (Pass) containing the allocated memory, or an error (Err) containing an AllocErr with a
    # message describing the failure. The only error that can occur in this method is a failure to allocate memory,
    # which is typically due to insufficient system resources.
    !public
    !abstract_method
    fun allocate(&self, layout: Layout) -> Res[Memory[E], AllocErr] { }

    # Deallocates a previously allocated block of memory. This method is abstract and must be implemented by any
    # subclass that extends Alloc. The method takes a Memory object as an argument, by move, which means that the caller
    # is transferring ownership of the memory to the allocator for deallocation. This makes manual de-allocation safe.
    !public
    !abstract_method
    fun deallocate(&self, mem: Memory[E]) -> Void { }

    # Allocates a block of memory for the specified layout, and initializes all bytes to zero. This method has a default
    # implementation that uses the allocate method to get a block of memory, and then uses the mem_set function from
    # sppc to set all bytes to zero. The method returns a Result type, as it has to handle the possibility of allocation
    # failure.
    !public
    !virtual_method
    fun allocate_zeroed(&self, layout: Layout) -> Res[Memory[E], AllocErr] {
        let mut mem = self.allocate(layout)?
        std::mem::ops::mem_set(&mut mem, 0_u8, layout.size * std::mem::ops::size_of[E]())
        ret Pass(val=mem)
    }

    # Reallocates a block of memory to a new size. This method has a default implementation that first deallocates the
    # existing memory block, and then allocates a new block of the desired size. The method returns a Result type, as it
    # has to handle the possibility of allocation failure during the new allocation.
    !public
    !virtual_method
    fun reallocate(&self, mem: Memory[E], layout: Layout) -> Res[Memory[E], AllocErr] {
        self.deallocate(mem)
        ret self.allocate(layout)
    }

    # Reallocates a block of memory to a new size, and initializes any new bytes to zero. This method has a default
    # implementation that first deallocates the existing memory block, and then allocates a new block of the desired
    # size using the allocate_zeroed method.
    !public
    !virtual_method
    fun reallocate_zeroed(&self, mem: Memory[E], layout: Layout) -> Res[Memory[E], AllocErr] {
        self.deallocate(mem)
        ret self.allocate_zeroed(layout)
    }
}


!public
cls GlobalAlloc[E] { }


sup [E] GlobalAlloc[E] ext Alloc[E] {
    fun allocate(&self, layout: Layout) -> Res[Memory[E], AllocErr] {
        # let mem = std::mem::ops::malloc[E](layout.size).ok_or_else(AllocErr::new)?
        let mem = std::mem::Memory[E, Self]()
        ret Pass(val=mem)
    }

    fun deallocate(&self, mem: Memory[E]) -> Void {
        std::mem::ops::free(mem)
    }

    fun allocate_zeroed(&self, layout: Layout) -> Res[Memory[E], AllocErr] {
        # let mem = std::mem::ops::calloc[E](layout.size).ok_or_else(AllocErr::new)?
        let mem = std::mem::Memory[E, Self]()
        ret Pass(val=mem)
    }

    fun reallocate(&self, mem: Memory[E], layout: Layout) -> Res[Memory[E], AllocErr] {
        # let mem = std::mem::ops::realloc(mem, layout.size).ok_or_else(AllocErr::new)?
        let mem = std::mem::Memory[E, Self]()
        ret Pass(val=mem)
    }
}
