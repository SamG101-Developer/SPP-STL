use std::boolean::Bool
use std::clone::Clone
use std::iterator::Iterator
use std::number::U8
use std::ops::eq::Eq
use std::ops::div::Div
use std::ops::ne::Ne
use std::option::None
use std::option::Opt
use std::option::Some
use std::process::Process
use std::string::Str


@public
cls Path {
    path: Str
}


sup Path {
    @public cmp sep: U8 = '/'
}


sup Path {
    @public
    fun is_absolute(&self) -> Bool {
        ret self.path.startswith(Str::from_char(self.sep))
    }

    @public
    fun is_relative(&self) -> Bool {
        ret self.is_absolute().not
    }

    @public
    fun to_absolute(&self) -> Path {
        # Get the current working directory and join with self.path.
        let cwd = Process::get_cwd()
        let abs_path = Path(path=cwd) / self.path
        ret abs_path
    }

    @public
    fun exists(&self) -> Bool {
        # Check if the path exists in the filesystem.
        let found = sppc::fs_exists(StrView::from(self.path.clone()))
        ret found
    }

    @public
    fun parent(&self) -> Path {
        # Get the parent directory of the path (which is the dir_name).
        let dir_name = self.dir_name()
        ret Path(path=dir_name)
    }
}


sup Path {
    @public
    fun file_name(&self) -> Opt[Str] {
        let parts = self.path.split(self.sep)
        # ret case parts.len() == 0_uz { None() } else { Some(val=parts.get_tail_ref().clone()) }
        ret None()
    }

    @public
    fun file_stem(&self) -> Opt[Str] {
        let file_name = self.file_name()
        # ret file_name.map(|name: Str| name.split('.')[0].clone())
        ret None()
    }

    @public
    fun extension(&self) -> Opt[Str] {
        let file_name = self.file_name()
        ret None()
        #ret file_name.map(|name: Str| {
        #    let parts = name.split('.')
        #    case parts.len() > 1 { Some(val=parts[parts.len() - 1]) } else { None() }
        #})
    }

    @public
    fun dir_name(&self) -> Str {
        # let parts = self.path.split(self.sep)
        # let parts = parts.iter_mov().take(parts.len() - 1)
        # ret Str::join(parts, self.sep)
        ret Str::from("")
    }

    @public
    fun split(&self) -> (Opt[Path], Opt[Path]) {
        let temp0: Opt[Path] = None()
        let temp1: Opt[Path] = None()
        ret (temp0, temp1)
        #ret (
            #self.dir_name().map(|dir: Str| Path(path=dir)),
            #self.file_name().map(|file: Str| Path(path=file)))
    }

    @public
    fun split_ext(&self) -> (Path, Opt[Str]) {
        let parts = self.path.split('.')
        # ret (Path(path=parts[0_uz]), case parts.len() > 1 { Some(val=parts.index_ref(1).clone()) } else { None() })
        let dummy: Opt[Str] = Some(val=Str())
        ret (Path(), dummy)
    }
}


sup Path {
    @public
    fun is_file(&self) -> Bool {
        let test = sppc::fs_is_file(StrView::from(self.path.clone()))
        ret test
    }

    @public
    fun is_dir(&self) -> Bool {
        let test = sppc::fs_is_dir(StrView::from(self.path.clone()))
        ret test
    }

    @public
    fun is_symlink(&self) -> Bool {
        let test = sppc::fs_is_symlink(StrView::from(self.path.clone()))
        ret test
    }
}


sup Path {
    @public
    fun join(&self, other: Str) -> Path {
        let mut new_path = self.path.clone()
        case new_path.endswith(Str::from_char(self.sep)).not {
            new_path += Str::from_char(self.sep)
        }
        new_path += other
        ret Path(path=new_path)
    }

    @public
    fun with_added_extension(&self, ex: Str) -> Path {
        let mut new_path = self.path.clone()
        case ex.length() > 0_uz {
            new_path += Str::from_char('.')
            new_path += ex
        }
        ret Path(path=new_path)
    }

    @public
    fun with_extension(&self, ex: Str) -> Path {
        let (base_path, _) = self.split_ext()
        let mut new_path = base_path.path.clone()
        case ex.length() > 0_uz {
            new_path += Str::from_char('.')
            new_path += ex
        }
        ret Path(path=new_path)
    }

    @public
    fun with_file_name(&self, name: Str) -> Path {
        let dir = self.dir_name()
        let mut new_path = dir.clone()
        case new_path.endswith(Str::from_char(self.sep)).not {
            new_path += Str::from_char(self.sep)
        }
        new_path += name
        ret Path(path=new_path)
    }
}


sup Path {
    @public
    cor iter_mov(self) -> Iterator[Str] {
        let parts = self.path.split(self.sep)
        gen with parts.iter_mov()
    }

    @public
    cor iter_mut(&mut self) -> Iterator[&mut Str] {
        let parts = self.path.split(self.sep)
        gen with parts.iter_mut()
    }

    @public
    cor iter_ref(&self) -> Iterator[&Str] {
        let parts = self.path.split(self.sep)
        gen with parts.iter_ref()
    }
}


sup Path ext Clone[Out=Path] {
    fun clone(&self) -> Path {
        ret Path(path=self.path.clone())
    }
}


sup Path ext Div[Rhs=Str, Ret=Path] {
    fun div(self, that: Str) -> Path {
        ret self.join(that)
    }
}


sup Path ext Div[Rhs=Path, Ret=Path] {
    fun div(self, that: Path) -> Path {
        ret self.join(that.path)
    }
}


sup Path ext Eq[Rhs=Path] {
    fun eq(&self, that: &Path) -> Bool {
        ret self.path.eq(&that.path)
    }
}


sup Path ext Ne[Rhs=Path] {
    fun ne(&self, that: &Path) -> Bool {
        ret self.path.ne(&that.path)
    }
}
