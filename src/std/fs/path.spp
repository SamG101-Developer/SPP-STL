use std::boolean::Bool
use std::clone::Clone
use std::iterator::IterRef
use std::ops::eq::Eq
use std::ops::div::Div
use std::ops::ne::Ne
use std::option::Opt
use std::string::Str


cls Path {
    path: Str
}


sup Path {
    @no_impl
    fun is_absolute(&self) -> Bool { }

    @no_impl
    fun is_relative(&self) -> Bool { }

    @no_impl
    fun to_absolute(&self) -> Path { }

    @no_impl
    fun to_relative(&self) -> Path { }

    @no_impl
    fun exists(&self) -> Bool { }

    @no_impl
    fun parent(&self) -> Path { }
}


sup Path {
    @no_impl
    fun startswith(&self, prefix: &Str) -> Bool { }

    @no_impl
    fun endswith(&self, suffix: &Str) -> Bool { }
}


sup Path {
    fun file_name(&self) -> Opt[Str] {
        let parts = self.path.split(self.sep_char())
        ret case parts.len() == 0 { None() } else { Some(parts.get_tail().clone()) }
    }

    fun file_stem(&self) -> Opt[Str] {
        let file_name = self.file_name()
        ret file_name.map(|name: Str| name.split(".")[0].clone())
    }

    fun extension(&self) -> Opt[Str] {
        let file_name = self.file_name()
        ret file_name.map(|name: Str| {
            let parts = name.split(".")
            case parts.len() > 1 { Some(parts[parts.len() - 1]) } else { None() }
        })
    }

    fun dir_name(&self) -> Str {
        let parts = self.path.split(self.sep_char())
        let parts = parts.iter_mov().take(parts.len() - 1)
        ret Str::join(parts, self.sep_char())
    }

    fun split(&self) -> (Opt[Path], Opt[Path]) {
        ret (
            self.dir_name().map(|dir: Str| Path(path=dir)),
            self.file_name().map(|file: Str| Path(path=file)))
    }

    fun split_ext(&self) -> (Path, Opt[Str]) {
        let parts = self.path.split(".")
        ret (Path(path=parts[0]), case parts.len() > 1 { Some(parts[1]) } else { None() })
    }
}


sup Path {
    @no_impl
    fun is_file(&self) -> Bool { }

    @no_impl
    fun is_dir(&self) -> Bool { }

    @no_impl
    fun is_symlink(&self) -> Bool { }
}


sup Path {
    @no_impl
    fun join(&self, other: Str) -> Path { }

    @no_impl
    fun with_added_extension(&self, ext: Str) -> Path { }

    @no_impl
    fun with_extension(&self, ext: Str) -> Path { }

    @no_impl
    fun with_file_name(&self, name: Str) -> Path { }
}


sup Path {
    @no_impl
    fun sep_char(&self) -> Str { }

    @no_impl
    fun cur_dir_char(&self) -> Str { }

    @no_impl
    fun par_dir_char(&self) -> Str { }
}


sup Path ext IterRef[Str] {
    @no_impl
    fun iter_ref(&self) -> Iter[&Str] { }
}


sup Path ext Clone {
    fun clone(&self) -> Path {
        ret Path(path=self.path.clone())
    }
}


sup Path ext Div[Rhs=Str, Ret=Path] {
    fun div(self, that: Str) -> Path {
        ret self.join(that)
    }
}


sup Path ext Div[Rhs=Path, Ret=Path] {
    fun div(self, that: Path) -> Path {
        ret self.join(that.path)
    }
}


sup Path ext Eq[Rhs=Path] {
    fun eq(&self, that: Path) -> Bool {
        ret self.path.eq(that.path)
    }
}


sup Path ext Ne[Rhs=Path] {
    fun ne(&self, that: Path) -> Bool {
        ret self.path.ne(that.path)
    }
}
