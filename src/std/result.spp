use std::boolean::Bool
use std::copy::Copy
use std::option::Opt
use std::option::None
use std::option::Some
use std::string::Str


@public cls Pass[T] { val: T }
@public cls Fail[E] { err: E }
@public type Res[T, E] = Pass[T] or Fail[E]


# Todo: "T: Copy, E: Copy"
sup [T, E] Res[T, E] ext Copy { }


sup [T, E] Res[T, E] {
    @public
    @inline
    fun ok(self) -> Opt[T] {
        let converted: Opt[T] = case self of {
           is Pass[T](val) { Some(val) }
           is Fail[E](err) { None() }
        }
    }
}


sup [T, E] Res[T, E] ext std::ops::try::Try[Pass[T], Fail[E], T] {
    fun op_is_value(&self) -> Bool {
        ret *self is Pass[T](..)
    }

    fun op_as_value(self) -> T {
        ret case self of {
            is Pass[T](val) { val }
            else { std::abort::abort("called `op_as_value` on a `Fail` value") }
        }
    }
}
